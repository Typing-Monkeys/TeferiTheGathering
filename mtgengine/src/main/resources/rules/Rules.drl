//created on: 9-giu-2014
package rules
//http://mtg.dmi.unipg.it/mancini/rest-server/api/cardGame/6322
//list any import classes here.
import com.magicengine.Game;
import com.magicengine.Ability;
import com.magicengine.AbilityOnTheStack;
import com.magicengine.Player;
import com.magicengine.DBCard;
import com.magicengine.DBCard.Face;
import com.magicengine.Action;
import com.magicengine.Attempt;
import com.magicengine.Phase;
import com.magicengine.GameEngine;
import com.magicengine.Step;
import com.magicengine.MakeChoice;
import com.magicengine.ChoiceOption;
import com.magicengine.ChoiceAnswer;
import com.magicengine.Zone;
import com.magicengine.Mana;
import com.magicengine.ManaSymbol;
import com.magicengine.ManaAbility;
import com.magicengine.Card;
import com.magicengine.Spell;
import com.magicengine.Permanent;
import com.magicengine.PrivateGame;
import com.magicengine.DebugGame;
import com.magicengine.Target;
import com.magicengine.MagicObject;
import com.magicengine.RulePriorityCounter;
import java.util.*;
import org.kie.api.runtime.KieSession;

rule "updateClients"
	dialect "mvel"
	agenda-group "general"
	salience 100
	no-loop true
	
	when
		$g : Game()
		$p : Player($id: id)
	then
		PrivateGame privateGame = new PrivateGame($g, $id);
		GameEngine.sendToNode(privateGame, Game.GAME_STATUS, Game.UNKNOWN, $id);	
end

rule "updateDebug"
	dialect "mvel"
	agenda-group "general"
	salience 100
	no-loop true
	
	when
		$g : Game()
	then
		DebugGame debugGame = new DebugGame($g);
		GameEngine.sendToNode(debugGame, Game.GAME_STATUS, Game.UNKNOWN, 999);	
end



rule "102.1"
/* 
--- November 19, 2021 ---
A player is one of the people in the game. 
The active player is the player whose turn it is. 
The other players are nonactive players. 
*/
dialect "mvel"
agenda-group "general"
salience 300
no-loop true
	when
		$g : Game(stage == Game.GAME_STAGE, turnTimeFrame==Game.BEGIN_TIME_FRAME, $ap : activePlayer, $t:turnOrder ) 
		$pl : Player($idAp : id) from $ap.getObject()
	then	
		$g.nonActivePlayers.clear();
		for(Player p : $t){
		 	if(p.id != $idAp) $g.nonActivePlayers.add(p);}
		System.out.print("Rule 102.1 --> Non active players: ");  
		for(int i=0;i<$g.nonActivePlayers.size();i++){
		 	 System.out.print(" " + $g.nonActivePlayers.get(i).nickname + " - ");
		}
		System.out.print("\n");
		update($g);
end
/**
rule "103.2"
/*
--- November 19, 2021 ---
103.2. After the starting player has been determined, each player shuffles their deck so that the cards
are in a random order. Each player may then shuffle or cut their opponents' decks. 
The players' decks become their libraries.

dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, startingPlayer.index != -1)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() == 0);
		
	then
		$lib.addAll($deck);
		for(Card c : $lib){
			c.idOwner = $id;
			c.faceDown = true;
		}
		$lib.shuffle();
		System.out.println("Rule 103.2: Shuffled deck of "  + $nickname);
		update($p);
end


rule "103.1" 
/*
--- November 19, 2021 ---
103.1. At the start of a game, the players determine which one of them will choose who takes 
the first turn. In the first game of a match (including a single-game match), 
the players may use any mutually agreeable method 
(flipping a coin, rolling dice, etc.) to do so. 
In a match of several games, the loser of the previous game chooses who takes the first turn. 
If the previous game was a draw, the player who made the choice in that game makes the choice in this game. 
The player chosen to take the first turn is the starting player. 
The game's default turn order begins with the starting player and proceeds clockwise.

dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE, $n : playersNumber, chooserPlayer.index == -1)
		
	then
		Random r = new Random();
		$g.setIndexChooserPlayer(r.nextInt($n));
		$g.chooserPlayer = $g.indexChooserPlayer;
		System.out.println("Rule 103.1 --> Chooser Player:  " + $g.chooserPlayer.getObject().nickname);
		GameEngine.sendToNode("Il player " + $g.chooserPlayer.getObject().nickname + " sceglie lo Starting Player");
		MakeChoice choice = new MakeChoice();
		choice.idChoice = Game.CHOOSE_STARTING_PLAYER;
		choice.choiceText = "Choose the starting player";
		for(Player player : $g.priorityOrder) {
			choice.addOption(player.id, player.nickname);
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.chooserPlayer.getObject().id);
		update($g);
end

rule "103.1 answerHandler"
/* Wait response for starting player 
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE,chooserPlayer.index != -1)
		$ca: ChoiceAnswer(idChoice == Game.CHOOSE_STARTING_PLAYER, idPlayer == $g.chooserPlayer.getObject().id)
	then
		for(Player player : $g.priorityOrder) {
			if(player.id == $ca.idOptions.get(0))
			{
				$g.startingPlayer = $g.priorityOrder.indexOf(player);
			}
		}				
		System.out.println("Rule 103.1 --> Starting Player Received: " + $g.startingPlayer.getObject().nickname);
		GameEngine.sendToNode("Il player " + $g.startingPlayer.getObject().nickname + " e' stato scelto come Starting Player");
		retract($ca);
		update($g);
end
*/

rule "103.1"
/* At the start of a game, each player shuffles his or her deck so that the cards
are in a random order. Each player may then shuffle or cut his or her opponents' decks. The players decks become their libraries. */
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() == 0);
		
	then
		$lib.addAll($deck);
		for(Card c : $lib){
			c.idOwner = $id;
			c.faceDown = true;
		}
		$lib.shuffle();
		System.out.println("Rule 103.1: Shuffled deck of "  + $nickname);
		update($p);
end

rule "103.2" // TODO: Gestire il caso non partita singola o non prima partita
/*103.2: After the decks have been shuffled, the players determine which one of them will 
choose who takes the first turn. In the first game of a match 
(including a single-game match), the players may use any mutually 
agreeable method (flipping a coin, rolling dice, etc.) to do so. 
In a match of several games, the loser of the previous game chooses 
who takes the first turn. If the previous game was a draw, the player 
who made the choice in that game makes the choice in this game. The player 
chosen to take the first turn is the starting player. The game�s default turn 
order begins with the starting player and proceeds clockwise. 
TODO: il giocatore estratto deve poter scegliere chi inizia */
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE, $n : playersNumber, chooserPlayer.index == -1)
		forall
		(
			$p: Player(library.size() > 0)
		)
		
	then
		Random r = new Random();
		$g.setIndexChooserPlayer(r.nextInt($n));
		$g.chooserPlayer = $g.indexChooserPlayer;
		System.out.println("Rule 103.2 --> Chooser Player:  " + $g.chooserPlayer.getObject().nickname);
		GameEngine.sendToNode("Il player " + $g.chooserPlayer.getObject().nickname + " sceglie lo Starting Player");
		MakeChoice choice = new MakeChoice();
		choice.idChoice = Game.CHOOSE_STARTING_PLAYER;
		choice.choiceText = "Choose the starting player";
		for(Player player : $g.priorityOrder) {
			choice.addOption(player.id, player.nickname);
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.chooserPlayer.getObject().id);
		update($g);
end

rule "103.2 answerHandler"
/* Wait response for starting player */
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE,chooserPlayer.index != -1)
		$ca: ChoiceAnswer(idChoice == Game.CHOOSE_STARTING_PLAYER, idPlayer == $g.chooserPlayer.getObject().id)
	then
		for(Player player : $g.priorityOrder) {
			if(player.id == $ca.idOptions.get(0))
			{
				$g.startingPlayer = $g.priorityOrder.indexOf(player);
			}
		}				
		System.out.println("Rule 103.2 --> Starting Player Received: " + $g.startingPlayer.getObject().nickname);
		GameEngine.sendToNode("Il player " + $g.startingPlayer.getObject().nickname + " e' stato scelto come Starting Player");
		retract($ca);
		update($g);
end


rule "103.3" // And 118.1
/* 
--- November 19, 2021 ---
103.3: Each player begins the game with a starting life total of 20.
Some variant games have different starting life totals. 
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, startingPlayer.index != -1);
		$p : Player($nickname: nickname, lifeTotal == -1);
	then
		$p.lifeTotal = 20;
		System.out.println("Rule 103.3 -->  Player Starting Life Total: " + $nickname + " = 20");
		update($p);
end

rule "103.4 part 1"
/* 
--- November 19, 2021 ---
103.4: Setting starting hand size */
/* TODO: Da gestire in futuro il numero di carte iniziale (quando ci saranno effetti)  */
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE);
		$p : Player($nickname: nickname, lifeTotal != -1, startingHandSize == -1);
	then
		$p.startingHandSize = 7;
		System.out.println("Rule 103.4 part 1 -->  Player Starting Hand Size: " + $nickname + " = 7");
		update($p);
end	

rule "103.4 part 2"
/*
--- November 19, 2021 ---
103.4. Each player draws a number of cards equal to their starting hand size, 
which is normally seven. (Some effects can modify a player's starting hand size.) 
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, mulliganPhase == false)
		$p : Player($id: id, $nickname: nickname, 
					$startingHandSize: startingHandSize, 
					$lib: library, 
					startingHandSize != -1,
					$hand: hand, hand.size() == 0,
					mulliganCounter == 0);
	then
		$p.draw($startingHandSize);
		for (Card card : $p.hand) {
			System.out.println(card.getAbilities());
		}
		System.out.println("Rule 103.4 part 2 -->  Player " + $nickname + " drawed " + $hand.size() + " cards");
		update($p);
end

rule "103.4 part 2.5"
/* 
--- November 19, 2021 ---
Inizio della fase di mulligan
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, 
					mulliganPhase == false, 
					scryTurn == false, 
					discardTurn == false,
					finishedEndPhaseOfMulligan == false)
		// tutti i giocatori hanno pescato la prima mano
		forall(
			Player( hand.size() > 0)
		)
	then
		System.out.println("Rule 103.4 part 2.5 --> Inizio fase di mulligan");
		$g.mulliganPhase = true;
		update($g);
end


rule "103.4 part 3a" 
/*
--- November 19, 2021 ---
A player who is dissatisfied with their initial hand may take a mulligan.
First, the starting player declares whether they will take a mulligan.  
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, startingPlayer.index != -1, 
			      mulliganPriorityMarker.index == -1, mulliganFlag == false, mulliganPhase == true)		
	then
		for(int i = $g.startingPlayer.index; i < $g.priorityOrder.size(); i++) {
			$g.mulliganPriorityOrder.add($g.priorityOrder.get(i));
		}
		for(int i = 0; i < $g.startingPlayer.index; i++) {
			$g.mulliganPriorityOrder.add($g.priorityOrder.get(i));
		}
		$g.mulliganPriorityMarker.movePointer(0);
		System.out.println("Rule 103.4 part 3a -->  Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
		GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
		MakeChoice choice = new MakeChoice();
		choice.idChoice = Game.TAKE_MULLIGAN;
		choice.choiceText = "Take Mulligan?";
		choice.addOption(1, "Yes");
		choice.addOption(2, "No");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.mulliganPriorityMarker.getObject().id);
		update($g);
end

rule "103.4 part 3b"
/* 
--- November 19, 2021 ---
Then each other player in turn order does the same.
Once each player has made a declaration,
all players who decided to take mulligans do so at the same time. To take a mulligan,
a player shuffles his or her hand back into his or her library, then draws a new hand 
of one fewer cards than he or she had before. If a player kept his or her hand of cards, 
those cards become the players opening hand, and that player may not take any further
mulligans. This process is then repeated until no player takes a mulligan.
(Note that if a players hand size reaches zero cards, that player must keep that hand.) 
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, mulliganType != Game.LONDON_MULLIGAN, mulliganFlag == true, mulliganPhase == true); 
	then
		if ($g.mulliganPriorityOrder.size() > 0) {
			if($g.mulliganPriorityMarker.hasNext()) {
				$g.mulliganPriorityMarker.next();
				p = $g.mulliganPriorityMarker.getObject();
				if(p.mulliganCounter == p.startingHandSize) {
					$g.mulliganPriorityMarker.remove();
					$g.mulliganPriorityMarker.index = $g.mulliganPriorityMarker.index - 1;
				} else {
					MakeChoice choice = new MakeChoice();
					choice.idChoice = Game.TAKE_MULLIGAN;
					choice.choiceText = "Take Mulligan?";
					choice.addOption(1, "Yes");
					choice.addOption(2, "No");
					GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.mulliganPriorityMarker.getObject().id);
					System.out.println("Rule 103.4 part 3b --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
					GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
					$g.mulliganFlag = false;	
				}			
			} else {
				for(Player player : $g.mulliganPriorityOrder) {
					player.takeMulligan($g.mulliganType);
					System.out.println("Rule 103.4 part 3b --> Player " + player.nickname + " is taking Mulligan");
					GameEngine.sendToNode("Player " + player.nickname + " is taking Mulligan");
				}
				$g.mulliganPriorityMarker.toHead();
			}
		} else {
			System.out.println("mulliganPriorityOrder size 0");
			//La fase di scry si attiva solo quando il mulligan scelto � VANCOUVER
			if($g.mulliganType==Game.VANCOUVER_MULLIGAN){
				$g.scryTurn = true; /** Set to true to initialize successively the scry phase */ 
			}
			$g.mulliganPhase = false; /** Terminate the mulligan phase once each player don't take mulligan */
		}
		
		update($g);
end


rule "103.4 part 3b (London Mulligan)"
/*
--- November 19, 2021 ---
Then each other player in turn order does the same. 
Once each player has made a declaration, all players who decided to take mulligans do so 
at the same time. To take a mulligan, a player shuffles the cards in their hand back 
into their library, draws a new hand of cards equal to their starting hand size, 
then puts a number of those cards equal to the number of times that player has taken a 
mulligan on the bottom of their library in any order. 
Once a player chooses not to take a mulligan, the remaining cards become that player's opening hand, 
and that player may not take any further mulligans. 
This process is then repeated until no player takes a mulligan. 
A player can take mulligans until their opening hand would be zero cards, after which they may not 
take further mulligans.
*/
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE, mulliganType == Game.LONDON_MULLIGAN, mulliganFlag == true, mulliganPhase == true); 
	then
		if ($g.mulliganPriorityOrder.size() > 0) {
			if($g.mulliganPriorityMarker.hasNext()) {
				$g.mulliganPriorityMarker.next();
				p = $g.mulliganPriorityMarker.getObject();
				if(p.mulliganCounter == p.startingHandSize) {
					$g.mulliganPriorityMarker.remove();
					$g.mulliganPriorityMarker.index = $g.mulliganPriorityMarker.index - 1;
				} else {
					MakeChoice choice = new MakeChoice();
					choice.idChoice = Game.TAKE_MULLIGAN;
					choice.choiceText = "Take Mulligan?";
					choice.addOption(1, "Yes");
					choice.addOption(2, "No");
					GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.mulliganPriorityMarker.getObject().id);
					System.out.println("Rule 103.4 part 3b (London) --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
					GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Mulligan");
					$g.mulliganFlag = false;	
				}			
			} else {
				for(Player player : $g.mulliganPriorityOrder) {
					player.takeMulligan($g.mulliganType);
					System.out.println("Rule 103.4 part 3b (London) --> Player " + player.nickname + " is taking Mulligan");
					GameEngine.sendToNode("Player " + player.nickname + " is taking Mulligan");
				}
				$g.mulliganPriorityMarker.toHead();
			}
		} else {
			System.out.println("mulliganPriorityOrder size 0");
			// Termina la fase di pescaggio
			$g.mulliganPhase = false;			
			$g.mulliganFlag = false;
			// Inizia la fase di scarto
			$g.discardTurn = true;
		}
		
		update($g);
end


rule "103.4 part 3b answerHandlerYes"
/* Handle answer for taking Mulligan */
dialect "mvel"
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE);
		$ca: ChoiceAnswer(idChoice == Game.TAKE_MULLIGAN, idPlayer == $g.mulliganPriorityMarker.getObject().id, idOptions.get(0) == 1)
	then
		System.out.println("Rule 103.4 part 3b answerHandlerYes --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " will take Mulligan");
		GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " will take Mulligan");
		$g.mulliganFlag = true;
		retract($ca);
		update($g);
end

rule "103.4 part 3b answerHandlerNo (con scry)"
	/* Handle answer for taking Mulligan */
	dialect "mvel"
	agenda-group "general"
	
	when
		$g : Game(stage == Game.STARTING_STAGE, mulliganType == Game.VANCOUVER_MULLIGAN);
		$ca: ChoiceAnswer(idChoice == Game.TAKE_MULLIGAN, idPlayer == $g.mulliganPriorityMarker.getObject().id, idOptions.get(0) == 2)
	then
		System.out.println("Rule 103.4 part 3b answerHandlerNo --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " will not take Mulligan");
		GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " will not take Mulligan");
		$g.mulliganPriorityMarker.remove();
		$g.mulliganPriorityMarker.index = $g.mulliganPriorityMarker.index - 1;
		$g.mulliganFlag = true;
		
		/* If a player takes mulligan, then we must inserts he/she into the scry list*/
		Player p = $g.mulliganPriorityMarker.getObject();
		if (p.mulliganCounter > 0) {
			$g.scryPriorityOrder.add(p);
		}
		
		
		retract($ca);
		update($g);
end

rule "103.4 part 3b answerHandlerNo (senza scry) per Paris/London mulligan"
	/* Handle answer for taking Mulligan */
	dialect "mvel"
	agenda-group "general"
	
	when
		$g : Game(stage == Game.STARTING_STAGE, mulliganType != Game.VANCOUVER_MULLIGAN);
		$ca: ChoiceAnswer(idChoice == Game.TAKE_MULLIGAN, idPlayer == $g.mulliganPriorityMarker.getObject().id, idOptions.get(0) == 2)
	then
		System.out.println("Rule 103.4 part 3b answerHandlerNo --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " will not take Mulligan");
		GameEngine.sendToNode("Player " + $g.mulliganPriorityMarker.getObject().nickname + " will not take Mulligan");
		$g.mulliganPriorityMarker.remove();
		$g.mulliganPriorityMarker.index = $g.mulliganPriorityMarker.index - 1;
		$g.mulliganFlag = true;
		
		retract($ca);
		update($g);
end

rule "103.4 part 3c" //Vancouver Scry choice
/* 
--- November 19, 2021 ---
After all players have kept an opening hand, each player in turn order whose hand contains 
fewer cards than that player's starting hand size may look at the top card of his or her 
library. If a player does, that player may put that card on the bottom of his or her library.
*/
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.STARTING_STAGE, mulliganPriorityOrder.size() == 0, mulliganFlag == true, mulliganPhase == false, 
				mulliganType == Game.VANCOUVER_MULLIGAN,
				scryTurn == true, finishedEndPhaseOfMulligan == false)
	then
		if ($g.scryPriorityOrder.size() > 0 && $g.scryPriorityMarker.hasNext()) {
			$g.scryPriorityMarker.next();
			
			MakeChoice choice = new MakeChoice();
			choice.idChoice = Game.TAKE_SCRY;
			choice.choiceText = "Take Scry?";
			choice.addOption(1, "Yes");
			choice.addOption(2, "No");
			GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.scryPriorityMarker.getObject().id);
			System.out.println("Rule 103.4 part 3c --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " have to declare if will take a Scry");
			GameEngine.sendToNode("Player " + $g.scryPriorityMarker.getObject().nickname + " have to declare if will take a Scry");
			$g.scryTurn = false; /* Set to false to avoid the rule's activation for other players */
		} else {
			System.out.println("Rule 103.4 part 3c --> part Finished scry phase");
			$g.finishedEndPhaseOfMulligan = true;
		}
		
		
		update($g)
end

rule "103.4 part 3c " //Vancouver scelta carta per Scry
/* 
--- November 19, 2021 ---
*/
	dialect "mvel"
	agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE, mulliganType == Game.VANCOUVER_MULLIGAN)
		$ca: ChoiceAnswer(idChoice == Game.TAKE_SCRY, idPlayer == $g.scryPriorityMarker.getObject().id, idOptions.get(0) == 1)
	then
		System.out.println("103.4 part3c -> Player " + $g.scryPriorityMarker.getObject().id + " did scry.");
	
		Player p = $g.scryPriorityMarker.getObject();
		Card c = p.library.pop();
		p.scryedCards.add(c);
		
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 10343;
		choice.choiceText = "Scryed " + c.getNameAsString + ". What do you want to do?";
		choice.addOption(1, "Put it on top of the library.");
		choice.addOption(2, "Put it at the bottom of the library.");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $g.scryPriorityMarker.getObject().id);
		System.out.println("Rule 103.4 part 3c --> Player " + $g.mulliganPriorityMarker.getObject().nickname + " has to decide.");
		GameEngine.sendToNode("Player " + $g.scryPriorityMarker.getObject().nickname + " has to decide");		
		
		retract($ca)
		update($g)
end

rule "103.4 part 3c playerAnswerActionToScry"
/* 
--- November 19, 2021 ---
*/
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.STARTING_STAGE, mulliganType == Game.VANCOUVER_MULLIGAN)
		$ca: ChoiceAnswer(idChoice == 10343, idPlayer == $g.scryPriorityMarker.getObject().id)
	then
		Player p = $g.scryPriorityMarker.getObject();
		
		System.out.println("103.4 part 3c playerAnswerActionToScry --> Player " + p.id + " has decided how to scry.");
	
		if ($ca.idOptions.get(0) == 1) {
			p.library.push(p.scryedCards.pop()); /* Player has decided to leave the card on top the library */
		} else {
			p.library.add(p.scryedCards.pop()); /* Player has decided to put the card at the bottom of the library */
		}
		
		$g.scryPriorityMarker.remove();
		$g.scryPriorityMarker.index = $g.scryPriorityMarker.index - 1;
		$g.scryTurn = true;
		
		retract($ca)
		update($g)
end

rule "103.4 part 3c playerAnswerNo"
/* 
--- November 19, 2021 ---
*/
	dialect "mvel"
	agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE, mulliganType == Game.VANCOUVER_MULLIGAN)
		$ca: ChoiceAnswer(idChoice == Game.TAKE_SCRY, idPlayer == $g.scryPriorityMarker.getObject().id, idOptions.get(0) == 2)
	then
		System.out.println("103.4 part 3c -> Player " + $g.scryPriorityMarker.getObject().id + " didn't scry.");
	
		$g.scryPriorityMarker.remove();
		$g.scryPriorityMarker.index = $g.scryPriorityMarker.index - 1;
		$g.scryTurn = true;
		
		retract($ca)
		update($g)
end


rule "103.4 part 3c mulligan LONDON"
/* 
--- November 19, 2021 ---
London Mulligan: Scelta delle carte da scartare
*/
dialect "mvel"
	agenda-group "general"
	when
		// il gioco è nella fase di scarto
		$g: Game(stage == Game.STARTING_STAGE, 
				 mulliganType == Game.LONDON_MULLIGAN, 
				 mulliganFlag == false,
				 mulliganPhase == false, 
				 discardTurn == true)
		// esiste un giocatore che non stà scartando e deve farlo
		$p: Player(!discarding, h: hand, shs: startingHandSize, mc: mulliganCounter)
		// un giocatore deve scartare quando il numero di crte nella sua mano
		// è maggiore del numero di carte iniziale meno il numero di mulligan effettuati
		eval(h.size() > shs - mc)
		
	then
		System.out.println("103.4 part 3c mulligan London -> Player "+ $p.getNickname() );
		// invio la scelta della prossima carta da scartare
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 11700;
		choice.choiceText = "Scegli quale carta scartare";
		for(int i = 0; i < $p.hand.size(); i++){
			choice.addOption(i, $p.hand.get(i).getNameAsString());
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $p.id);
		// imposto il giocatore nella fase di scarto
		$p.discarding = true;
		update($p)
		
end

rule "103.4 part 3c mulligan LONDON discard answer"
/* 
--- November 19, 2021 ---
London Mulligan: Gestione della risposta alla scelta
*/
dialect "mvel"
	agenda-group "general"
	when
		// il gioco è nella fase di scarto
		$g: Game(stage == Game.STARTING_STAGE, 
				 mulliganType == Game.LONDON_MULLIGAN, 
				 mulliganFlag == false,
				 mulliganPhase == false, 
				 discardTurn == true)
	    // un giocatore ha effettuato una scelta
		$ca: ChoiceAnswer(idChoice == 11700, pid: idPlayer , op_id: idOptions)
		$p: Player(id == pid)
	then
		// Carta scartata
		card_idx = Integer.valueOf((String) op_id.get(0));
		card = $p.hand.get(card_idx);
		System.out.println("103.4 part 3c mulligan LONDON discard answer-> Player " + pid + "discarded " + card.getNameAsString());
		// Scarto
		$p.sendToBottomLibrary(card);
		$p.discarding = false;
		retract($ca)
		update($p)
end


rule "103.4 part 3c mulligan LONDON discard end"
/* 
--- November 19, 2021 ---
London Mulligan: Terminazione della fase di scarto
*/
dialect "mvel"
	agenda-group "general"
	when
		// il gioco è nella fase di scarto
		$g: Game(stage == Game.STARTING_STAGE, 
				 mulliganType == Game.LONDON_MULLIGAN, 
				 mulliganFlag == false,
				 mulliganPhase == false, 
				 discardTurn == true)
		// nessun giocatore deve scartare
		forall (
			$p: Player(!discarding, 
			           shs: startingHandSize, 
			           mc: mulliganCounter, 
			           h: hand, h.size() == shs - mc) 
		)		
	then
		System.out.println("103.4 part 3c mulligan LONDON discard end -> Terminata fase di mulligan.");
		// Fine della fase di scarto
		$g.discardTurn = false;
		// Terminazione del Mulligan
		$g.finishedEndPhaseOfMulligan = true;
		update($g)
end


rule "103.7"
/* 
--- November 19, 2021 ---
103.7: The starting player takes his or her first turn. */
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.STARTING_STAGE, finishedEndPhaseOfMulligan == true, activePlayer.index == -1);
		forall( 
				Player($t : turn)
				Phase(!this.isEmpty(), name == "ending") from $t 
			)
			  
	then
		$g.activePlayer = $g.startingPlayer;
		System.out.println("Rule 103.7 --> Active Player:  " + $g.activePlayer.getObject().nickname);		
		$g.currentPhase = $g.activePlayer.getObject().turn; 
		System.out.println("Rule 103.7 --> currentPhase:  "  + $g.currentPhase.getObject().name);
		$g.currentStep = $g.currentPhase.getObject();								
		System.out.println("Rule 103.7 --> currentStep:  "  + $g.currentStep.getObject().name);		
		GameEngine.sendToNode("Starting Player: "  + $g.startingPlayer.getObject().nickname);
		String toNode = "-/";
		if($g.activePlayer.getObject()!=null) toNode = toNode + "Active Player: "+$g.activePlayer.getObject().nickname;
		if($g.currentPhase.getObject()!=null) toNode = toNode + " / Current Phase: " + $g.currentPhase.getObject().name;
		if($g.currentStep.getObject()!=null)  toNode = toNode + " / Current Step: " + $g.currentStep.getObject().name;
		GameEngine.sendToNode(toNode);
		$g.stage = Game.GAME_STAGE;
		update($g);
end

// 104. Ending the game
rule "104.2a"
/* 
--- November 19, 2021 ---
A player still in the game wins the game if all of that player's opponents have left the game. 
This happens immediately and overrides all effects that would prevent that player from winning the game. 
*/
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 5000
	
	when
		$g: Game(stage == Game.GAME_STAGE, $to: turnOrder, $po: priorityOrder)
		$p: Player() from $to[0]
		eval($to.size == 1 && $po.size == 1 && $to[0] == $po[0])
	then
		System.out.println("104.2a --> The player " + $p.nickname + " has won the game.");
		GameEngine.sendToNode("104.2a --> The player " + $p.nickname + " has won the game.");
		
		$p.hasWin = Player.PLAYER_WIN;
		$g.stage = Game.GAME_FINISHED;
		update($g)
end

rule "104.2b"
/* 
--- November 19, 2021 ---
An effect may state that a player wins the game. 
*/
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end

rule "104.2c"
/* 
--- November 19, 2021 ---
In a multiplayer game between teams, a team with at least one player still in the game
wins the game if all other teams have left the game. Each player on the winning team wins 
the game, even if one or more of those players had previously lost that game. 
*/
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end

rule "104.2d"
/* 
--- November 19, 2021 ---
In an Emperor game, a team wins the game if its emperor wins the game. (See rule 809.5.) 
*/
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end

rule "104.4a"
/* 
--- November 19, 2021 ---
If all the players remaining in a game lose simultaneously, the game is a draw. 
*/
	dialect "mvel"
	agenda-group "general"
	salience 5000
	
	when
		$g: Game(stage == Game.GAME_STAGE, $to: turnOrder, $po: priorityOrder)
		eval($to.size == 0 && $po.size == 0)
	then
		System.out.println("104.4a --> The game is a draw.");
		GameEngine.sendToNode("104.4a --> The game is a draw.");
		
		for (Player p : $g.players) {
			p.hasWin = Player.PLAYER_DRAW;
		}
		
		$g.stage = Game.GAME_FINISHED;
		update($g)
end

// 106. Mana
rule "106.1"
	dialect "mvel"
	agenda-group "general"
	
	when
		
	then
	
end

rule "106.4a"
/*
--- November 19, 2021 ---
106.4a
If a player passes priority (see rule 117) while there is mana in his
or her mana pool, that player announces what mana is there. 
--- November 19, 2021 ---
106.4b
If any mana remains in a player's mana pool after he or she spends mana to 
pay a cost, that player announces what mana is still there. 
*/
	dialect "mvel"
	agenda-group "general"
	no-loop true
	
	when
		Game(stage == Game.GAME_STAGE, $pm: priorityMarker.object)
		$p: Player($id : id) from $pm
		Action(id==$id , command == Game.TAKE_ACTION , option==Game.PASS_PRIORITY)
	then
		GameEngine.sendToNode("Il Mana Pool del giocatore " + $p.Nickname + " e' il seguente: " + $p.printManaPool());
		System.out.println("106.4a --> Il mana pool del giocatore " + $p.nickname + " è il seguente " + $p.printManaPool());
end

//SPECIAL ACTIONS

rule "116.1" 
/*
--- November 19, 2021 ---
	116.1 NUOVO NUMERO
Special actions are actions a player may take when he or she has priority that don't use the stack. 
These are not to be confused with turn-based actions and state-based actions, which the game generates automatically*/
dialect "mvel"
agenda-group "general"
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "116.2a" 
/*
--- November 19, 2021 ---
	116.2A NUOVO NUMERO
Playing a land is a special action. To play a land, a player puts that land onto the battlefield from the zone it was in 
(usually that player's hand). By default, a player can take this action only once during each of his or her turns. 
A player can take this action any time he or she has priority and the stack is empty during a main phase of his or her turn.*/
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.GAME_STAGE, $ac: activePlayer.getObject())
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id) from $ac
		$ca: ChoiceAnswer(idChoice == 11611, idPlayer == $id, idOptions.get(0) == Game.PLAY_LAND)
	then
		System.out.println("Rule 116.2a --> PLAYER " + $p.nickname + " wants to play a land");
		
		$p.wantsPlayLand = true;
		
		retract($ca);
		update($g);
end

rule "116.2b" 
/*
--- November 19, 2021 ---
	116.2B NUOVO NUMERO
Turning a face-down creature face up is a special action. A player can take this action any time he or she has priority.*/
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.GAME_STAGE)
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 11611, idPlayer == $id, idOptions.get(0) == Game.TURN_CREATURE_FACE_UP)
	then
		System.out.println("Rule 116.2b --> PLAYER " + $p.nickname + " wants to turn a creature face up");
		GameEngine.sendToNode("Player " + $p.nickname + " to turn a creature face up");
		
		// TODO: da implementare
		
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
		
		retract($ca);
		update($g);
end






//TIMING AND PRIORITY

rule "117.1" 
/*
--- November 19, 2021 ---
	117.1 NUOVO NUMERO
Unless a spell or ability is instructing a player to take an action, which player can take actions at 
any given time is determined by a system of priority. The player with priority may cast spells, 
activate abilities, and take special actions.*/
dialect "mvel"
agenda-group "general"
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.1a"
/*
--- November 19, 2021 ---
	117.1A NUOVO NUMERO
A player may cast an instant spell any time he or she has priority. A player may cast a noninstant 
spell during his or her main phase any time he or she has priority and the stack is empty.*/
dialect "mvel"
agenda-group "general"
	when
		$a: Attempt($id: id)
		$p: Player(id==$id)	
		$g: Game(stage == Game.GAME_STAGE, priorityMarker.getObject() != null && priorityMarker.getObject() == $p)		
		$act : Action(id==$id)
		forall
		(
			Action(option != Game.CAST_INSTANT_SPELL && option != Game.CAST_NON_INSTANT_SPELL && option != Game.TAKE_SPECIAL_ACTION)
		)		
		eval(($a.option == Game.CAST_INSTANT_SPELL ) ||
				( $g.activePlayer.getObject().id==$id &&
					($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main") &&
						$g.stack.isEmpty() && $a.option == Game.CAST_NON_INSTANT_SPELL ) )
	then					
		modify($act) {setId($a.getId()),  setCommand($a.getCommand()), setOption($a.getOption()), setOption2($a.getOption2())};
		retract($a);
		System.out.println("Rule 116.1a --> ATTEMPT VALIDATO");
		GameEngine.sendToNode("ATTEMPT VALIDATO: id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);
		System.out.println("id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);
		
		// Da attivare in caso di necessità
		//$p.manaPool.add(new Mana("red","red"));
		//$p.manaPool.add(new Mana("red","red"));
		//$p.manaPool.add(new Mana("red","red"));
		//$p.manaPool.add(new Mana("black","black"));
		//$p.manaPool.add(new Mana("black","black"));
		//$p.manaPool.add(new Mana("black","black"));
		//$p.manaPool.add(new Mana(new ManaSymbol("{U}")));
		//$p.manaPool.add(new Mana(new ManaSymbol("{U}")));
		//$p.manaPool.add(new Mana(new ManaSymbol("{U}")));
		//$p.manaPool.add(new Mana(new ManaSymbol("{W}")));
		//$p.manaPool.add(new Mana(new ManaSymbol("{W}")));
		//$p.manaPool.add(new Mana("white","white"));
		
		//for(Player player : $g.priorityOrder){
		//	if(player.id != $id){
		//		retract(player.action);
		//		player.action = new Action(player.id,0,0,0);
		//		insert(player.action);
		//		System.out.println("elimino action: " + player.action);	
		//	}			
		//}
		
		update($g);
end

rule "117.1b"
/*
--- November 19, 2021 ---
	117.1B NUOVO NUMERO
A player may activate an activated ability any time he or she has priority.*/
dialect "mvel"
agenda-group "general"
	when
		$a: Attempt($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id==$id)	
		$g: Game(stage == Game.GAME_STAGE, priorityMarker.getObject() != null && priorityMarker.getObject() == $p)
		$act : Action(id==$id)
		forall
		(
			// TODO: rivedere condizione
			Action(command == 0, option == 0, option2 == 0)
		)
	then	
		modify($act) {setId($a.getId()),  setCommand($a.getCommand()), setOption($a.getOption()), setOption2($a.getOption2())};
		retract($a);
		System.out.println("Rule 117.1b --> ATTEMPT VALIDATO");
		GameEngine.sendToNode("ATTEMPT VALIDATO: id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);	
		System.out.println("id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);
		
		update($g);
end

rule "117.1c"
/*
--- November 19, 2021 ---
	117.1C NUOVO NUMERO
A player may take some special actions any time he or she has priority. A player may take other 
special actions during his or her main phase any time he or she has priority and the stack is empty.*/
dialect "mvel"
agenda-group "general"
	when
		$a: Attempt($id: id)
		$p: Player(id==$id)	
		$g: Game(stage == Game.GAME_STAGE, priorityMarker.getObject() != null && priorityMarker.getObject() == $p)
		$act : Action(id==$id)
		forall
		(
			Action(option != Game.CAST_INSTANT_SPELL && option != Game.CAST_NON_INSTANT_SPELL && option != Game.TAKE_SPECIAL_ACTION)
		)
		eval($g.activePlayer.getObject().id==$id && $a.option == Game.TAKE_SPECIAL_ACTION)
	then			
		modify($act) {setId($a.getId()),  setCommand($a.getCommand()), setOption($a.getOption()), setOption2($a.getOption2())};
		retract($a);
		System.out.println("Rule 117.1c --> ATTEMPT VALIDATO");
		GameEngine.sendToNode("ATTEMPT VALIDATO: Il giocatore " + $p.nickname + " deve scegliere quale Special Action attivare");
		System.out.println("id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);
		
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 11611;
		choice.choiceText = "Choose what Special Action to activate";
		choice.addOption(Game.PLAY_LAND, "Play Land");
		choice.addOption(Game.TURN_CREATURE_FACE_UP, "Turn Creature face up");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		
		update($g);	
end

//martina-damiano aggiunta la possibilità di attivare le mana ability delle terre, vengono selezionate dal battlefield se non sono già state tappate precedentemente
rule "117.1d"
	/*
	--- November 19, 2021 ---
		117.1d NUOVO NUMERO
	A player may activate a mana ability whenever he or she has priority, whenever he or she is casting 
	a spell or activating an ability that requires a mana payment, or whenever a rule or effect asks for 
	a mana payment (even in the middle of casting or resolving a spell or activating or resolving 
	an ability).*/
	agenda-group "general"

	when
		$a: Attempt($id: id, option == Game.ACTIVATE_MANA_ABILITY)
		$p: Player(id==$id)	
		$g: Game(stage == Game.GAME_STAGE, priorityMarker.getObject() != null && priorityMarker.getObject() == $p)
		$act : Action(id==$id)
		forall
		(
			// TODO: rivedere condizione
			Action(command == 0, option == 0, option2 == 0)
		)	
	then
		modify($act) {
			setId($a.getId()),
			setCommand($a.getCommand()),
			setOption($a.getOption()),
			setOption2($a.getOption2())
		};
		retract($a);
		
		System.out.println("Rule 117.1d --> ATTEMPT VALIDATO");
		GameEngine.sendToNode("ATTEMP VALIDATO: Il giocatore " + $p.getNickname() + " deve scegliere quale abilità di mana attivare");
		System.out.println("id:"+$act.getId()+"comm" +$act.getCommand()+" opt" + $act.getOption()+"opt2 " +$act.getOption2());
		
		MakeChoice choice = new MakeChoice();
		choice.setIdChoice(11614);
		choice.setChoiceText("Choose which permanents you want tap");
		for (MagicObject mo : $g.getBattleField()) {
			Permanent p = (Permanent) mo;
			if(p.getIdController() == $id && !p.getStatus().isTapped() && 
				p.getStatus().isFaceUp() && p.getStatus().isPhasedIn()) {
				
				LinkedList<Ability> abilities;
				if (!p.getStatus().isFlipped()) {
					abilities = p.getAbilities().get(0);
				} else {
					abilities = p.getAbilities().get(1);
				} 
	
				// Modificare in futuro nel caso in cui devono essere gestiti
				// più ManaSymbol.
				for (Ability abilita : abilities) {
					String ability=abilita.getAbilityText();
					if (abilita.isMana_ability()) {
						choice.addOption(p.getMagicTargetId(), p.getNameAsString());
					}
				}
			}
		}
		
		if (choice.getChoiceOptions().size() > 0) {
			System.out.println("Carte aggiunte: " + choice.getChoiceOptions().size());
			GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
		} else {
			GameEngine.sendToNode("117.1d --> The player " + $p.getNickname() + " does not have permanents to tap.");
			retract($p.getAction());
			$p.setAction(new Action($id,0,0,0));
			insert($p.getAction());
		}
		
		update($g)
		
end

//martina-damiano aggiunta la generazione del tipo di mana corrispondente se la mana ability selezionata appartiene a una terra
rule "117.1d answerHandler"
	agenda-group "general"
	
	when		
		$a: Action($id: id, option == Game.ACTIVATE_MANA_ABILITY)
		$g: Game(stage == Game.GAME_STAGE, $pm: priorityMarker)
		$p: Player(id == $id) from $pm.object
		$ca: ChoiceAnswer(idChoice == 11614, idPlayer == $id)
	then
		
		if ($ca.getIdOptions().size() > 0) {
			System.out.println("117.1d answerHandler --> The player " + $p.getNickname() + " has tapped some permanents.");
			for (String a : $ca.getIdOptions()) {
				for (MagicObject mo : $g.getBattleField()) {
					Permanent p = (Permanent) mo;
					if (a.equals(Integer.toString(p.getMagicTargetId()))) {
						p.getStatus().setTapped(true);
						
						LinkedList<Ability> abilities;
						if (!p.getStatus().isFlipped()) {
							abilities = p.getAbilities().get(0);
						} else {
							abilities = p.getAbilities().get(1);
						}
						
						for (Ability abilita : abilities) {
							
							if (abilita.isMana_ability()) {
								String[] manaSymbols = {"{B}", "{G}", "{R}", "{U}", "{W}", "{C}"};
								String abilitaText = abilita.getAbilityText();
								String[] cuttedText = abilitaText.split("dd \\{"); 
								String refinedAbilitaText = "{" + cuttedText[1];								
								for (String manaSym : manaSymbols) {
									int count = -1, fromIndex = 0;
							        while ((fromIndex = refinedAbilitaText.indexOf(manaSym, fromIndex)) != -1 ){
							            count++;
							            fromIndex++;							            
							        }
									//int count = StringUtils.countMatches(refinedAbilitaText, manaSym);
									for (int i=0; i<=count; i++){
										$p.getManaPool().add(new Mana(new ManaSymbol(manaSym)));
									}
								}
							}							
						}
					}
				}
			}
			System.out.println("117.1d answerHandler --> The player " + $p.getNickname() + " has tapped some permanents");		
		} else {
			System.out.println("117.1d answerHandle --> The player " + $p.getNickname() + " has not tapped permanents.");
		}
		
		retract($p.getAction());
		$p.setAction(new Action($id,0,0,0));
		insert($p.getAction());
		
		retract($ca)
		update($g)
end 

rule "117.2"
/*
--- November 19, 2021 ---
	117.2 NUOVO NUMERO
Other kinds of abilities and actions are automatically generated or performed by the game rules, 
or are performed by players without receiving priority.*/
dialect "mvel"
agenda-group "general"
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.2a"
/*
--- November 19, 2021 ---
	117.2A NUOVO NUMERO
Triggered abilities can trigger at any time, including while a spell is being cast, an ability is 
being activated, or a spell or ability is resolving. (See rule 603, �Handling Triggered Abilities.�) 
However, nothing actually happens at the time an ability triggers. Each time a player would receive 
priority, each ability that has triggered but hasn�t yet been put on the stack is put on the stack. 
See rule 117.5.*/
dialect "mvel"
agenda-group "general"
//da gestire con le carte
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.2b"
/*
--- November 19, 2021 ---
	117.2B NUOVO NUMERO
Static abilities continuously affect the game. Priority doesn�t apply to them. 
(See rule 604, �Handling Static Abilities,� and rule 611, �Continuous Effects.�)*/
dialect "mvel"
agenda-group "general"
//da gestire con le static-abilities 
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.2c"
/*
--- November 19, 2021 ---
	117.2C NUOVO NUMERO
Turn-based actions happen automatically when certain steps or phases begin. They�re dealt with 
before a player would receive priority. See rule 117.3a. Turn-based actions also happen automatically 
when each step and phase ends; no player receives priority afterward. See rule 703, �Turn-Based Actions.�*/
dialect "mvel"
agenda-group "general"
//da gestire con le turn-based actions
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.2d"
/*
--- November 19, 2021 ---
	117.2D NUOVO NUMERO
State-based actions happen automatically when certain conditions are met. See rule 704. 
They�re dealt with before a player would receive priority. See rule 117.5.*/
dialect "mvel"
agenda-group "general"
no-loop
//da gestire con le state-based actions
	when
		$g: Game(stage == Game.GAME_STAGE)
	then
end

rule "117.2e"
	/*
	--- November 19, 2021 ---
		117.2E NUOVO NUMERO
	Resolving spells and abilities may instruct players to make choices or take actions, or may allow 
	players to activate mana abilities. Even if a player is doing so, no player has priority while a 
	spell or ability is resolving. See rule 608, �Resolving Spells and Abilities.�*/
	dialect "mvel"
	agenda-group "general"
 	// da gestire con le carte
	when
		Game(stage == Game.GAME_STAGE)
	then
end

//Rule 117.3 Which player has priority is determined by the following rules:
rule "117.3a"
	/*
	--- November 19, 2021 ---
	The active player receives priority at the beginning of most steps and phases, after any turn-based 
	actions (such as drawing a card during the draw step; see rule 703) have been dealt with and abilities 
	that trigger at the beginning of that phase or step have been put on the stack. No player receives 
	priority during the untap step. Players usually don�t get priority during the cleanup step 
	(see rule 514.3).*/
	/* da implementare per le abilit� che vanno nello stack*/
	dialect "mvel"
	agenda-group "general"
	
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.3b"
/*
--- November 19, 2021 ---
The active player receives priority after a spell or ability (other than a mana ability) resolves.*/
dialect "mvel"
agenda-group "general"
	when
		$g: Game(stage == Game.GAME_STAGE, resolvedSpell == true, stepTimeFrame==Game.DURING_TIME_FRAME || 
		phaseTimeFrame==Game.DURING_TIME_FRAME, resolvingSpell == null) 		
		forall( Player($id : id) Action(id==$id , option==Game.PASS_PRIORITY) )	
	then
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
		}
		$g.priorityMarker.movePointer($g.activePlayer.getObject());
		$g.resolvedSpell = false;
		System.out.println("117.3b -> The active player " + $g.activePlayer.getObject().nickname + " received priority");	
		update($g);
end

rule "117.3c"
/*
--- November 19, 2021 ---
If a player has priority when he or she casts a spell, activates an ability, or takes a special action, 
that player receives priority afterward.*/
dialect "mvel"
agenda-group "general"
no-loop true
	when
		$g : Game(stage == Game.GAME_STAGE, $pm : priorityMarker)
		$p : Player($id : id) from $pm.object
		$act : Action(id == $id, option == Game.CAST_NON_INSTANT_SPELL || option == Game.ACTIVATE_ABILITY || option == Game.TAKE_SPECIAL_ACTION) 
	then
		System.out.println("Rule 117.3c pre movePointer " + $p.nickname);
		$pm.movePointer($p); 
		System.out.println("Rule 117.3c: " + $p.nickname);
		
		update($g)
end

rule "117.3d"
/*
--- November 19, 2021 ---
If a player has priority and chooses not to take any actions, that player passes. If any mana is in 
that player�s mana pool, he or she announces what mana is there. Then the next player in turn order 
receives priority.*/
dialect "mvel"
no-loop true
agenda-group "general"
	when
		$g : Game(stage == Game.GAME_STAGE, $pm : priorityMarker)
		$p : Player($id : id) from $pm.object
		$a : Attempt(id == $id, command == Game.TAKE_ACTION, option == Game.PASS_PRIORITY)
		$act : Action(id == $id)
		forall
		(
			Action(option == 0 || option == Game.PASS_PRIORITY)
		)
	then			
		modify($act) {setId($a.getId()),  setCommand($a.getCommand()), setOption($a.getOption()), setOption2($a.getOption2())};
		retract($a);
		GameEngine.sendToNode("ATTEMPT VALIDATO: id:"+$act.id+"comm" +$act.command+" opt" + $act.option+"opt2 " +$act.option2);
		System.out.println("Rule 117.3d: " + $p.nickname);
		$g.controlStateBasedActions = true;
		update($g);
end

rule "117.4"
/*
--- November 19, 2021 ---
If all players pass in succession (that is, if all players pass without taking any actions in between 
passing), the spell or ability on top of the stack resolves or, if the stack is empty, the phase or step
ends.*/
dialect "mvel"
agenda-group "general"
//Dipende dalle carte. Risolvere lo stack
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.5"
	/*
	--- November 19, 2021 ---
	Each time a player would get priority, the game first performs all applicable state-based actions as a 
	single event (see rule 704, �State-Based Actions�), then repeats this process until no state-based actions
	are performed. Then triggered abilities are put on the stack (see rule 603, �Handling Triggered Abilities�).
	These steps repeat in order until no further state-based actions are performed and no abilities trigger. 
	Then the player who would have received priority does so.
	Il processo di priority va controllato.
	*/
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $pm: priorityMarker.object, controlStateBasedActions)
		$p: Player($id: id) from $pm
		$a: Action(id == $id, option == Game.PASS_PRIORITY)
		not RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS)
	then
		System.out.println("117.5 --> Controlling state-based actions before priority assignments to " + $p.nickname);
	
		LinkedList ruleList = new LinkedList();
		ruleList.addAll([
			"704.5a",
			"704.5b",
			"704.5c",
			"704.5f",
			"702.2b",
			"704.5g",
			"704.5i",
			"704.5j"
		]);
		
		insert(
			new RulePriorityCounter(
				RulePriorityCounter.STATE_BASED_ACTIONS,
				ruleList
			)
		)
		
		// Initializes ausiliary list used to iterate the players in the rule 704.5j		
		$g.sevenzerofourPlayerOrder = $g.priorityOrder.clone();
		$g.sevenzerofourPlayerMarker.listReference = $g.sevenzerofourPlayerOrder;
		$g.sevenzerofourPlayerMarker.next();
		$g.playerHasToMakeChoiceszf = false;
		
		update($g)
end

rule "117.6"
/*
--- November 19, 2021 ---
In a multiplayer game using the shared team turns option, teams rather than individual players have 
priority. See rule 805, �Shared Team Turns Option.�*/
dialect "mvel"
agenda-group "general"
	when
		Game(stage == Game.GAME_STAGE)
	then
end

rule "117.7"
/*
--- November 19, 2021 ---
If a player with priority casts a spell or activates an activated ability while another spell or ability
is already on the stack, the new spell or ability has been cast or activated �in response to� the earlier 
spell or ability. The new spell or ability will resolve first. See rule 608, �Resolving Spells and 
Abilities.�*/
dialect "mvel"
agenda-group "general"
	when
		Game(stage == Game.GAME_STAGE)
	then
end


rule "120.3a"
/*
--- November 19, 2021 ---
120.3a. Damage dealt to a player by a source without infect causes that player to lose that much life.*/
dialect "mvel"
agenda-group "general"
salience 300
when
	$g: Game(stage == Game.GAME_STAGE)
	$p: Player(damageDealt>0) from $g.priorityOrder
then
	$p.lifeTotal = $p.lifeTotal - $p.damageDealt;
	System.out.println("120.3a -> "+$p.nickname+" perde "+$p.damageDealt+" punti vita");
	System.out.println("120.3a -> "+$p.nickname+" life total is "+$p.lifeTotal);
	$p.damageDealt = 0;
	update($g);
end


rule "120.3c"
/*
--- November 19, 2021 ---
120.3c. Damage dealt to a planeswalker causes that many loyalty counters to be removed from that planeswalker.*/
dialect "mvel"
agenda-group "general"
salience 300
when
	$g: Game(stage == Game.GAME_STAGE)
	$p: Permanent(damageDealt>0, cardType[0].contains("planeswalker")) from $g.battleField
then
	$p.loyalty[0] = Integer.parseInt($p.loyalty[0]) - $p.damageDealt;
	System.out.println("120.3c -> "+$p.getNameAsString()+" perde "+$p.damageDealt+" loyalty, ora ne ha "+$p.loyalty[0]);
	$p.damageDealt = 0;
	update($g);
end


rule "120.3e"
/*
--- November 19, 2021 ---
120.3e. Damage dealt to a creature by a source with neither wither nor infect causes 
that much damage to be marked on that creature.*/
dialect "mvel"
agenda-group "general"
salience 300
when
	$g: Game(stage == Game.GAME_STAGE)
	$p: Permanent(damageDealt>0, cardType[0].contains("creature")) from $g.battleField
then
	$p.markedDamage += $p.damageDealt;
	System.out.println($p.getNameAsString()+" ha "+$p.markedDamage+" danni segnati");
	$p.damageDealt = 0;
	$g.updateDamage = true;
	update($g);
end


rule "302.6"  //summoning sickness
/*
--- November 19, 2021 ---
302.6. A creature's activated ability with the tap symbol or the untap symbol 
in its activation cost can't be activated unless the creature has been under its 
controller's control continuously since his or her most recent turn began. A creature 
can't attack unless it has been under its controller's control continuously since his 
or her most recent turn began. This rule is informally called the "summoning sickness" rule*/
dialect "mvel"
agenda-group "general"
salience 250
no-loop true
	when
		$g: Game(stage == Game.GAME_STAGE, $ac : activePlayer, turnTimeFrame == Game.BEGIN_TIME_FRAME)
		$pa: Player($id : id) from $ac.object
		$pe: Permanent(summoningSickness == true, idController == $id) from $g.battleField
	then
		for(Permanent creature: $g.battleField){
			if(creature.idController == $id){
				creature.summoningSickness = false;
			}
		}
		System.out.println("302.6 -> summoning sickness settate a false");
		update($g)
end



rule "305.1"
	/**
		--- November 19, 2021 ---
	 * A player who has priority may play a land card from his or her hand during a main phase of his or 
	 * her turn when the stack is empty. Playing a land is a special action; it doesn't use the stack 
	 * (see rule 115). Rather, the player simply puts the land onto the battlefield. Since the land 
	 * doesn't go on the stack, it is never a spell, and players can't respond to it with instants or 
	 * activated abilities.
	 */
	dialect "mvel"
	agenda-group "general"
	when
		$g: Game(stage == Game.GAME_STAGE, $ac: activePlayer.getObject())		
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id, wantsPlayLand == true) from $ac
		eval($g.stack.size() > 0 || 
				($g.currentPhase.getObject().name != "precombat main" && $g.currentPhase.getObject().name != "postcombat main") )
	then
		System.out.println("305.1 --> Player " + $p.nickname + " cannot play a land because he/she is not in a main phase");
		GameEngine.sendToNode("305.1 --> Player " + $p.nickname + " cannot play a land because he/she is not in a main phase");
		
		$p.wantsPlayLand = false;
		
		retract($p.action)
		$p.action = new Action($id, 0, 0, 0);
		insert($p.action)
		
		update($g)
end


rule "305.2"
/* --- November 19, 2021 ---
305.2
A player can normally play one land during his or her turn; however, continuous effects may 
increase this number.
*/
	dialect "mvel"
	agenda-group "general"
	
	when
	then
end


rule "305.2a"
/* --- November 19, 2021 ---
305.2a
To determine whether a player can play a land, compare the number of lands the player can 
play this turn with the number of lands he or she has already played this turn (including 
lands played as special actions and lands played during the resolution of spells and abilities). 
If the number of lands the player can play is greater, the play is legal.
*/
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $ac: activePlayer.getObject(), $g.stack.size() == 0)		
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id, wantsPlayLand == true, playedLands < maxPlayableLands) from $ac
		eval($g.currentPhase.getObject().name == "precombat main" || $g.currentPhase.getObject().name == "postcombat main" )
	then
		System.out.println("305.2a --> Player " + $p.nickname + " can play the land.");
		GameEngine.sendToNode("305.2a --> Player " + $p.nickname + " can play the land.");
		
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 30521;
		choice.choiceText = "Choose which card to play";
		boolean found = false;
		
		for(Card card : $p.hand) {
			if(card.cardType.size() > 0 && card.cardType[0].contains("land")) {
				choice.addOption(card.magicTargetId, card.getNameAsString());
				found = true;
			}
		}
		
		if (found) {
			GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
			GameEngine.sendToNode("305.2a --> The player " + $p.nickname + " wants play a land.");
			System.out.println("Rule 305.2a --> The player " + $p.nickname + " wants play a land.");
		} else {
			GameEngine.sendToNode("305.2a --> The player " + $p.nickname + " has not land to play.");
			System.out.println("305.2a -> The player " + $p.nickname + "  has not land to play.");
			retract($p.action);
			$p.action = new Action($id,0,0,0);
			insert($p.action);
		}
		
		$p.wantsPlayLand = false;
		
		update($g)
end

rule "305.2a answerHandler"
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $ac: activePlayer.getObject())
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id) from $ac
		$ca: ChoiceAnswer(idChoice == 30521, idPlayer == $id)
	then
	
		System.out.println("305.2a answerHandler --> Player " + $p.nickname + " played a land");
		GameEngine.sendToNode("305.2a answerHandler --> Player " + $p.nickname + " played a land");
		
		Card selectedCard = null;
		for (Card card : $p.hand) {
			if (card.magicTargetId == $ca.idOptions.get(0)) {
				new_Permanent = new Permanent(card, $g.giveMeMyId(), $id, $g.getIdBattlefieldCounter());
				$g.battleField.add(new_Permanent);
				$p.playedLands += 1;
				selectedCard = card;	
			}
		}
		$p.hand.remove(selectedCard);
		
		
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
		
		retract($ca);
		update($g);
end



rule "305.2b"
	/** 
	 * A player can't play a land, for any reason, if the number of lands the player can play 
	 * this turn is equal to or less than the number of lands he or she has already played this 
	 * turn. Ignore any part of an effect that instructs a player to do so.
	 * 
	 * November 19, 2021
	 */ 
	dialect "mvel"
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $ac: activePlayer.getObject(), $g.stack.size() == 0)
		$act: Action($id: id, option == Game.TAKE_SPECIAL_ACTION)
		$p: Player(id == $id, wantsPlayLand == true, playedLands >= maxPlayableLands) from $ac
		eval($g.currentPhase.getObject().name == "precombat main" || $g.currentPhase.getObject().name == "postcombat main" )
	then
		System.out.println("305.2b --> Player " + $p.nickname + " can't play the land.");
		GameEngine.sendToNode("305.2b --> Player " + $p.nickname + " can't play the land.");
				
		$p.wantsPlayLand = false;
		
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
		
		update($g)
end




rule "400.1 & 400.2" 
/* --- November 19, 2021 ---
400.1. A zone is a place where objects can be during a game. 
There are normally seven zones: library, hand, battlefield, graveyard, stack, 
exile, and command. Some older cards also use the ante zone. Each player has his 
or her own library, hand, and graveyard. The other zones are shared by all players.

400.2. Public zones are zones in which all players can see the cards' faces, except for
those cards that some rule or effect specifically allow to be face down. Graveyard, 
battlefield, stack, exile, ante, and command are public zones. Hidden zones are zones
in which not all players can be expected to see the cards' faces. Library and hand
are hidden zones, even if all the cards in one such zone happen to be revealed.*/
dialect "mvel"
agenda-group "initialization"
no-loop true
	when
	then
	// Gestite a livello di creazione dell'oggetto
end


//TURN STRUCTURE - GENERAL

rule "500.1 & 505.1"
/*--- November 19, 2021 ---
500.1: A turn consists of five phases, in this order: 
beginning, precombat main, combat, postcombat main, and ending. 
Each of these phases takes place every turn, even if nothing happens 
during the phase. The beginning, combat, and ending phases are further 
broken down into steps, which proceed in order.

505.1: There are two main phases in a turn. In each turn, the first main phase 
(also known as the precombat main phase) and the second main phase 
(also known as the postcombat main phase) are separated by the combat phase 
(see rule 506, �Combat Phase�). The precombat and postcombat main 
phases are individually and collectively known as the main phase.*/
dialect "mvel"
agenda-group "initialization"
no-loop true
	when
		$g: Game()
		$p: Player( turn.isEmpty(), $t : turn ) 
	then
		$t.add(new Phase("beginning", false));
		$t.add(new Phase("precombat main",false));
		$t.add(new Phase("combat",false));
		$t.add(new Phase("postcombat main",false));
		$t.add(new Phase("ending",false));							
		update($p);		
		System.out.println("Rule 500.1 --> Player : "+$p.getNickname());
		System.out.println("Number of phases : " + $t.size());
end

rule "500.2 & 505.2"
/* --- November 19, 2021 ---
500.2: A phase or step in which players receive priority ends when the 
stack is empty and all players pass in succession. Simply having 
the stack become empty doesn�t cause such a phase or step to end; 
all players have to pass in succession with the stack empty. 
Because of this, each player gets a chance to add new things to the 
stack before that phase or step ends.

505.2: The main phase has no steps, so a main phase ends when all players 
pass in succession while the stack is empty. */
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, stack.isEmpty(), resolvingSpell == null, resolvedSpell == false, stepTimeFrame==Game.DURING_TIME_FRAME || phaseTimeFrame==Game.DURING_TIME_FRAME) 		
		forall( Player($id : id) Action(id==$id , option==Game.PASS_PRIORITY) )	
		
	then
		if($g.currentStep.size == 0){ 
			$g.phaseTimeFrame =$g.END_TIME_FRAME;
			System.out.println("505.2 Fase ad end");			
		}else{
			if($g.currentStep.hasNext()){
				$g.stepTimeFrame=$g.END_TIME_FRAME;
				System.out.println("505.2 Step ad end");
			}else{
				 $g.stepTimeFrame=$g.END_TIME_FRAME;
				 $g.phaseTimeFrame=$g.END_TIME_FRAME;
				 System.out.println("505.2 Step e Fase ad end");
			}
		}		
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
			System.out.println("elimino action: " + p.action);	
		} 
		
		$g.priorityMarker.toHead();
		update($g); 		 	
end


rule"500.3"
/* --- November 19, 2021 ---
A step in which no players receive priority ends when all specified actions 
that take place during that step are completed. The only such steps are the 
untap step (see rule 502) and certain cleanup steps (see rule 514).*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.4"
/* --- November 19, 2021 ---
When a step or phase ends, any unused mana left in a player�s mana pool empties. 
This turn-based action doesn�t use the stack.*/
dialect "mvel"
agenda-group "general"
no-loop true 

when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame==Game.END_TIME_FRAME || phaseTimeFrame==Game.END_TIME_FRAME) 
	$p: Player()		
then
	$p.manaPool.clear();
	update($p);
	System.out.println("500.4 ManaPool azzerato per il player: " +$p.getNickname());
end

rule "500.5"
/*--- November 19, 2021 ---
When a phase or step ends, any effects scheduled to last �until end of� that phase 
or step expire. When a phase or step begins, any effects scheduled to last �until� 
that phase or step expire. Effects that last �until end of combat� expire at the end 
of the combat phase, not at the beginning of the end of combat step. Effects that 
last �until end of turn� are subject to special rules; see rule 514.2.*/
//gestita dalle carte
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.6"
/*--- November 19, 2021 ---
When a phase or step begins, any abilities that trigger "at the beginning of" that phase or step trigger.
They are put on the stack the next time a player would receive priority. (See rule 117, "Timing and Priority.")*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
//da gestire con le carte 
then
end

rule "500.7"
/*--- November 19, 2021 ---
Some effects can give a player extra turns. They do this by adding the turns directly 
after the specified turn. If a player is given multiple extra turns, the extra turns
are added one at a time. If multiple players are given extra turns, the extra turns are added one at a time,
 in APNAP order (see rule 101.4). The most recently created turn will be taken first.*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.8"
/*--- November 19, 2021 ---
Some effects can add phases to a turn. They do this by adding the phases directly 
after the specified phase. If multiple extra phases are created after the same phase, 
the most recently created phase will occur first.*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.9"
/*--- November 19, 2021 ---
Some effects can add steps to a phase. They do this by adding the steps directly 
after a specified step or directly before a specified step. If multiple extra steps 
are created after the same step, the most recently created step will occur first.*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.10"
/*--- November 19, 2021 ---
Some effects can cause a step, phase, or turn to be skipped. To skip a step, 
phase, or turn is to proceed past it as though it didn�t exist. See rule 614.10.*/
dialect "mvel"
when
	Game(stage == Game.GAME_STAGE)
then
end

rule "500.11"
/* --- November 19, 2021 ---
No game events can occur between turns, phases, or steps.*/
agenda-group "general"
dialect "mvel"
salience -1
when
	$g : Game(stage == Game.GAME_STAGE, $st: stepTimeFrame == END_TIME_FRAME || $pt: phaseTimeFrame == END_TIME_FRAME 
			  || $tt: turnTimeFrame == END_TIME_FRAME)	
then
	
	do{
		if($g.currentStep.listReference.size()!=0 && $g.currentStep.getObject().additional) $g.currentStep.remove();
		if($g.currentPhase.listReference.size()!=0 && $g.currentPhase.getObject().additional) $g.currentPhase.remove();
		if($g.activePlayer.listReference.size()!=0 && $g.activePlayer.getObject().turn.additional) $g.activePlayer.remove();
		if($g.currentStep.hasNext()){ 
			$g.currentStep.next();
			$g.stepTimeFrame = Game.BEGIN_TIME_FRAME;
			
		}else if($g.currentPhase.hasNext()){
			$g.currentPhase.next();
			$g.phaseTimeFrame = Game.BEGIN_TIME_FRAME;
			$g.currentStep=$g.currentPhase.getObject();
			$g.stepTimeFrame = Game.BEGIN_TIME_FRAME;			
			
			if($g.currentStep.listReference.isEmpty()){
				$g.stepTimeFrame = Game.ABSENT_TIME_FRAME;
			}
			
		}else{
			if(!$g.activePlayer.hasNext()) $g.activePlayer.toHead();
			$g.activePlayer.next();
			$g.firstTurn = false;
			$g.turnTimeFrame = Game.BEGIN_TIME_FRAME;			
			$g.currentPhase=$g.activePlayer.getObject().turn;
			$g.phaseTimeFrame = Game.BEGIN_TIME_FRAME;			
			$g.currentStep=$g.currentPhase.getObject();
			$g.stepTimeFrame = Game.BEGIN_TIME_FRAME;			
		}
	
	}while(($g.currentStep.listReference.size()!=0 && $g.currentStep.getObject().toSkip) || ($g.currentPhase.getObject().toSkip) || ($g.activePlayer.getObject().turn.toSkip));
	if($g.activePlayer.getObject()!=null) System.out.println("500.11 -> Active Player: " + $g.activePlayer.getObject().nickname);
	if($g.currentPhase.getObject()!=null) System.out.println("500.11 -> Current Phase: " + $g.currentPhase.getObject().name);	
	if($g.currentStep.getObject()!=null) System.out.println("500.11 -> Current Step: " + $g.currentStep.getObject().name);
	System.out.println("500.11 -> Phase Time Frame: " + $g.phaseTimeFrame);
	System.out.println("500.11 -> Step Time Frame: " + $g.stepTimeFrame);
	String toNode = "-/";
	if($g.activePlayer.getObject()!=null) toNode = toNode + "Active Player: "+$g.activePlayer.getObject().nickname;
	if($g.currentPhase.getObject()!=null) toNode = toNode + " / Current Phase: " + $g.currentPhase.getObject().name;
	if($g.currentStep.getObject()!=null)  toNode = toNode + " / Current Step: " + $g.currentStep.getObject().name;
	GameEngine.sendToNode(toNode);				
	update($g);
	
end




//BEGINNING PHASE

rule "501.1"
/* --- November 19, 2021 ---
The beginning phase consists of three steps, in this order: 
untap, upkeep, and draw.*/
dialect "mvel"
agenda-group "initialization"
no-loop true
	when
		$p: Player() 
		$ph : Phase(this.isEmpty(), name == "beginning") from $p.turn		
	then		
		$ph.add(new Step("untap",false));		 		
		$ph.add(new Step("upkeep",false));
		$ph.add(new Step("draw",false));		
		System.out.println("Rule 501.1 --> Player:  "+$p.getNickname());
		System.out.println("Step's number of BEGINNING PHASE  : " + $ph.size());
		update($p);		
end

//UNTAP STEP

rule "502.1"
/*--- November 19, 2021 ---
First, all phased-in permanents with phasing that the active player 
controls phase out, and all phased-out permanents that the active player 
controlled when they phased out phase in. This all happens simultaneously. 
This turn-based action doesn�t use the stack. */
agenda-group "general"
dialect "mvel"
salience 200
//da gestire quando si hanno i permanenti con fase
when	
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "untap")
then
	System.out.println("502.1 permanenti fase");
end

rule "502.2"
/*--- November 19, 2021 ---
Second, the active player determines which permanents he or she controls 
will untap. Then he or she untaps them all simultaneously. 
This turn-based action doesn't use the stack. Normally, all of a player�s 
permanents untap, but effects can keep one or more of a player�s permanents 
from untapping.*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "untap")
	$p:Player($id:id) from $ac.object
then
	$g.stepTimeFrame = Game.DURING_TIME_FRAME;	
	$g.turnTimeFrame = Game.DURING_TIME_FRAME;
	$g.phaseTimeFrame = Game.DURING_TIME_FRAME;
	System.out.println("502.2 permanenti stap");
	for(Permanent creature : $g.battleField) {
		if(creature.idController == $id){
			creature.getStatus().setTapped(false);
			System.out.println(creature.getNameAsString()+" stappata");
		}
	}
	update($g);
end

rule "502.3"
/*--- November 19, 2021 ---
No player receives priority during the untap step, so no spells can be 
cast or resolve and no abilities can be activated or resolve. 
Any ability that triggers during this step will be held until the next 
time a player would receive priority, which is usually during the upkeep 
step.*/
agenda-group "general"
dialect "mvel"
salience -1
//da gestire abilita' che triggherano in questa step con la Salienza -1 e vanno messe nelle triggeredAbilieties
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.DURING_TIME_FRAME)
	eval($g.currentStep.getObject().name == "untap")
then
	$g.stepTimeFrame = Game.END_TIME_FRAME;
	System.out.println("502.3");
	update($g);
end

//UPKEEP STEP

rule "503.1"
	/* --- November 19, 2021 ---
	503.1. The upkeep step has no turn-based actions. Once it begins, the active player gets priority. (See rule 116, "Timing and Priority.")*/
	agenda-group "general"
	dialect "mvel"
	salience 100
	//gestire abilit� e magie
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "upkeep")
		$p : Player() from $ac.object
	then
		$g.priorityMarker.movePointer($p);
		$g.stepTimeFrame = Game.DURING_TIME_FRAME;
		System.out.println("503.1 priority player: " + $p.nickname);
		GameEngine.sendToNode("- Priority Player: " + $p.nickname +" - Active Player: " + $g.activePlayer.getObject().nickname);
		update($g);
end

rule "503.1a"
	/*--- November 19, 2021 ---
	503.1a. Any abilities that triggered during the untap step and any abilities that triggered at 
	the beginning of the upkeep are put onto the stack before the active player gets priority; the order 
	in which they triggered doesn't matter. (See rule 603, "Handling Triggered Abilities.")*/
	agenda-group "general"
	dialect "mvel"
	salience 200
	//da gestire abilit� che triggherano in questo step
	
	when	
		$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "upkeep")
		//$p : Player()
	then
		//$g.stack.addAll($p.triggeredAbilities); //carico nello stack le abilit� dello step untap L'ORDINE LO GESTISCE LA REGOLA 603.3b
end

rule "503.2"
	/*--- November 19, 2021 ---
	If a spell states that it may be cast only �after [a player�s] 
	upkeep step,� and the turn has multiple upkeep steps, that spell may 
	be cast any time after the first upkeep step ends*/
	agenda-group "general"
	dialect "mvel"
	//gestire magie in futuro
	when
		$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.DURING_TIME_FRAME)
		eval($g.currentStep.getObject().name == "upkeep")
	then
	
end

//DRAW STEP

rule "504.1 & 103.7a"
/* --- November 19, 2021 ---
First, the active player draws a card. This turn-based action doesn�t 
use the stack.*/
/* In a two-player game, the player who plays first skips the draw step 
(see rule 504, "Draw Step") of his or her first turn*/
agenda-group "general"
dialect "mvel"
salience 200
no-loop true
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME, firstTurn == false)
	eval($g.currentStep.getObject().name == "draw")
then
	$g.activePlayer.getObject().draw();
	System.out.println("504.1 Player " + $g.activePlayer.getObject().nickname + " drew a card.");
	update($g);
end

rule "504.2"
	/*--- November 19, 2021 ---
	 Second, the active player gets priority. (See rule 116, "Timing and Priority.") */
	agenda-group "general"
	dialect "mvel"
	salience 50
	//gestire abilit� e magie
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "draw")
		$p : Player() from $ac.object
	then
		$g.priorityMarker.movePointer($p);
		$g.stepTimeFrame = Game.DURING_TIME_FRAME;
		System.out.println("504.2 Priority player: " + $g.priorityMarker.getObject().nickname);
		GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
		update($g);
end


//MAIN PHASE

rule "505.1a"
/*
--- November 19, 2021 ---
Only the first main phase of the turn is a precombat main phase. All 
other main phases are postcombat main phases. This includes the second 
main phase of a turn in which the combat phase has been skipped. It is 
also true of a turn in which an effect has caused an additional combat 
phase and an additional main phase to be created.*/
salience 250
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, phaseTimeFrame == Game.BEGIN_TIME_FRAME )	
	eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main" )
then
	System.out.println("505.1a" );
end

rule "505.3"
/* --- November 19, 2021 ---
 First, but only if the players are playing an Archenemy game (see rule 904), the active player is the archenemy, 
 and it's the active player's precombat main phase, the active player sets the top card of their scheme deck in motion (see rule 701.25).
 This turn-based action doesn't use the stack.*/
salience 200
agenda-group "general"
dialect "mvel"
//gestire Archenemy
when
	$g:Game(stage == Game.GAME_STAGE, phaseTimeFrame == Game.BEGIN_TIME_FRAME )	
	eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main")
then	
		System.out.println("505.3");	
end

rule "505.4"
	/*
	--- November 19, 2021 ---
	505.4. Second, if the active player controls one or more Saga enchantments and it's the active player's precombat main phase,
	the active player puts a lore counter on each Saga they control. (See rule 715, "Saga Cards.")
	This turn-based action doesn't use the stack.
	 
	Vecchia regola
	Second, the active player gets priority. (See rule 116, "Timing and Priority.") */
	agenda-group "general"
	dialect "mvel"
	salience 100
	//gestire abilit� e magie
	when
		$g:Game(stage == Game.GAME_STAGE, phaseTimeFrame == Game.BEGIN_TIME_FRAME )	
		eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main" )
	then
		//$g.stack.addAll($p.triggeredAbilities); //carico nello stack le abilit� 
		System.out.println("505.4");
		//update($g);
end



rule "505.5"
/*
--- November 19, 2021 ---

505.5. Third, the active player gets priority. (See rule 117, "Timing and Priority.")

Third, the active player gets priority. Players may cast spells and 
activate abilities. The active player may play a land.*/

agenda-group "general"
dialect "mvel"
salience 50
//gestire abilit� e magie
when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, phaseTimeFrame == Game.BEGIN_TIME_FRAME )	
	eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main" )
	$p : Player() from $ac.object
then
	$g.phaseTimeFrame = Game.DURING_TIME_FRAME;
	$g.priorityMarker.movePointer($p);
	System.out.println("505.5 Priority player: " + $g.priorityMarker.getObject().nickname);
	GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
	update($g);
end

rule "505.5a"
	/*

	--- November 19, 2021 ---
	505.5a The main phase is the only phase in which a player can normally cast artifact,
	creature, enchantment, planeswalker, and sorcery spells. The active player may cast these spells.

	505.4a The main phase is the only phase in which a player can normally cast 
	artifact, creature, enchantment, planeswalker, and sorcery spells. 
	Only the active player may cast these spells*/
	agenda-group "general"
	dialect "mvel"
	//gestire abilit�, magie e terre se ha priorit�
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer)	
		eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main" )
		//$p : Player() from $ac.object
	then
		System.out.println("505.5a");
end

rule "505.5b"
	/*

	--- November 19, 2021 ---
	
	505.5b During either main phase, the active player may play one land card from their hand if the stack is empty,
	if the player has priority, and if they haven't played a land this turn (unless an effect states the player
	may play additional lands). This action doesn't use the stack. Neither the land nor the action of playing the
	land is a spell or ability, so it can't be countered, and players can't respond to it with instants or activated abilities. (See rule 305, "Lands.")



	505.4b During either main phase, the active player may play one land card from 
	his or her hand if the stack is empty, if the player has priority, 
	and if he or she hasn�t played a land this turn (unless an effect states 
	the player may play additional lands). This action doesn�t use the stack. 
	Neither the land nor the action of playing the land is a spell or ability, 
	so it can�t be countered, and players can�t respond to it with instants or 
	activated abilities.*/
	agenda-group "general"
	dialect "mvel"
	//verranno implementate in futuro le 305 che gestiscono le terre
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stack.isEmpty()==true)	
		eval($g.currentPhase.getObject().name=="precombat main" || $g.currentPhase.getObject().name=="postcombat main" )
		//$p : Player() from $ac.object
	then
		//In java � stato settato il playableLands a 1. See rule 117.1c
		System.out.println("505.5b");
end

rule "506.1 part 1"
	/*
	--- November 19, 2021 ---
	The combat phase has five steps, which proceed in order:
	beginning of combat, declare attackers, declare blockers,
	combat damage, and end of combat.*/
	agenda-group "initialization"
	dialect "mvel"
	salience 100
	when 
		$p: Player() 
		$ph : Phase(this.isEmpty(), name == "combat") from $p.turn
	then
		$ph.add(new Step("beginning of combat",false));		 		
		$ph.add(new Step("declare attackers",false));
		$ph.add(new Step("declare blockers",false));
		$ph.add(new Step("combat damage",false));
		$ph.add(new Step("end of combat",false));		
		System.out.println("Rule 506.1 --> Player:  "+$p.getNickname());
		System.out.println("Step's number of COMBAT PHASE  : " + $ph.size());
		update($p);	
end	


rule "506.1 part 2"
	//gestita in 508
	/*
	--- November 19, 2021 ---
	The declare blockers and combat damage steps are skipped if no creatures are declared as 
		attackers or put onto the battlefield attacking (see rule 508.8).*/
	dialect "mvel"
	when
		Game(stage == Game.GAME_STAGE);
	then
end


rule "506.1 part 3"
/* Tommaso Romani Nicol� Posta
There are two combat damage steps if any attacking or blocking creature has first strike 
(see rule 702.7) or double strike (see rule 702.4).*/
dialect "mvel"
salience 50
no-loop true
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE, $bf: battleField, $ph: currentPhase.getObject())
	eval($g.currentPhase.getObject().name == "combat")
	eval($ph.size() <= 5)
	//TODO: mettere che siano tra gli attaccanti o i bloccanti
	exists (Permanent(
			(checkKeywordAbility("Double strike") || checkKeywordAbility("First strike"))
		) from $bf)
then
	System.out.println("506.1 part 3 -> Aggiunto combat damage per First/Double strike");
	
	$ph.remove($ph.size()-1);
	$ph.remove($ph.size()-1);
	$ph.add(new Step("combat damage",true));
	$ph.add(new Step("combat damage",false));
	$ph.add(new Step("end of combat",false));
	System.out.println("Size prima dell'aggiunta" + $ph.size());


		
	update($g)

end

		
rule "506.2" 
 /*
 --- November 19, 2021 ---
 During the combat phase, the active player is the attacking player;
 creatures that player controls may attack. During the combat phase
 of a two-player game, the nonactive player is the defending player;
 that player and planeswalkers he or she controls may be attacked.*/
dialect "mvel"
agenda-group "general"
salience 300
no-loop true
	when
		$g:Game(stage == Game.GAME_STAGE, phaseTimeFrame == Game.BEGIN_TIME_FRAME )	
		eval($g.currentPhase.getObject().name=="combat")
		eval($g.attackingPlayer.index == -1)
	then
		$g.attackingPlayer.movePointer($g.activePlayer.object);
		System.out.println("Rule 506.2 two player --> Attacking Player:  "+$g.attackingPlayer.getObject().nickname);
		if($g.twoPlayerGame == true){
			for(Player nonActive : $g.nonActivePlayers){
				$g.defendingPlayers.addObject(nonActive);
				System.out.println("506.2 -> defending player: "+nonActive.nickname);
			}
			
		}
		update($g);
end

rule "506.3"
//Gestita indirettamente
/*
--- November 19, 2021 ---
506.3. Only a creature can attack or block. Only a player or a planeswalker can be attacked.*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE)
then
end


rule "506.4"
/*
--- November 19, 2021 ---
506.4. A permanent is removed from combat if it leaves the battlefield, if its 
controller changes, if it phases out, if an effect specifically removes it from combat, 
if it's a planeswalker that's being attacked and stops being a planeswalker, or if it's 
an attacking or blocking creature that regenerates (see rule 701.12 NEW rule 701.13) or stops being a 
creature. A creature that's removed from combat stops being an attacking, blocking, 
blocked, and/or unblocked creature. A planeswalker that's removed from combat stops 
being attacked.*/
dialect "mvel"
agenda-group "general"
salience 500
	when
		$g:Game(stage == Game.GAME_STAGE, $bf : battleField)
		$p:Permanent(removedFromCombat == true) from $bf
		
	then
		System.out.println("506.4 -> "+$p.getNameAsString()+" viene rimosso dal combattimento");
		$g.attackingCreatures.remove($p);
		$g.blockingCreatures.remove($p);
		$p.attacking = false;
		$p.attackAlone = false;
		$p.attackingAlone = false;
		$p.blocking = false;
		$p.blockAlone = false;
		$p.blockingAlone = false;
		$p.blocked = false;
		$p.target = null;
		$p.combatDamage = 0;
		$p.damageDealt = 0;
		
		for(Permanent blocker : $p.blockedBy.listReference){
			blocker.blockedCreatures.remove($p);
			blocker.damageAssignmentOrder.remove($p);
		}
		for(Permanent attacker : $p.blockedCreatures.listReference){
			attacker.blockedBy.remove($p);
			attacker.damageAssignmentOrder.remove($p);
		}
		$p.blockedBy.toHead();
		$p.blockedBy.listReference.clear();
		$p.blockedCreatures.toHead();
		$p.blockedCreatures.listReference.clear();
		$p.damageAssignmentOrder.toHead();
		$p.damageAssignmentOrder.listReference.clear();
		$p.target = null;
		if($p.cardType[0].contains("planeswalker")){
			for(Permanent attacker : $g.attackingCreatures.listReference){
				if(attacker.target == $p){
					attacker.target = null;
				}
			}
		}
		$p.removedFromCombat = false;
		update($g);
end


rule "506.5 attacking alone"
/*
--- November 19, 2021 ---
506.5. A creature attacks alone if it's the only creature declared as an attacker during the 
declare attackers step. A creature is attacking alone if it's attacking but no other creatures 
are. A creature blocks alone if it's the only creature declared as a blocker during the declare 
blockers step. A creature is blocking alone if it's blocking but no other creatures are.*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE, attackingCreatures.getSize()==1)
	$p:Permanent(attackingAlone == false) from $g.attackingCreatures.listReference
then
	System.out.println("506.5 -> "+$p.getNameAsString()+" sta attaccando da sola");
	$p.attackingAlone = true;
	update($g);
end


rule "506.5 blocking alone"
/*--- November 19, 2021 ---*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE, blockingCreatures.getSize()==1)
	$p:Permanent(blockingAlone == false) from $g.blockingCreatures.listReference
then
	System.out.println("506.5 -> "+$p.getNameAsString()+" sta bloccando da sola");
	$p.blockingAlone = true;
	update($g);
end


rule "506.5 not attacking alone"
/*--- November 19, 2021 ---*/
/*506.5. A creature attacks alone if it's the only creature declared as an attacker during the 
declare attackers step. A creature is attacking alone if it's attacking but no other creatures 
are. A creature blocks alone if it's the only creature declared as a blocker during the declare 
blockers step. A creature is blocking alone if it's blocking but no other creatures are.*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE, attackingCreatures.getSize()>1)
	$p:Permanent(attackingAlone == true) from $g.attackingCreatures.listReference
then
	System.out.println("506.5 -> "+$p.getNameAsString()+" non sta attaccando da sola");
	$p.attackingAlone = false;
	update($g);
end


rule "506.5 not blocking alone"
/*--- November 19, 2021 ---*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE, blockingCreatures.getSize()>1)
	$p:Permanent(blockingAlone == true) from $g.blockingCreatures.listReference
then
	System.out.println("506.5 -> "+$p.getNameAsString()+" non sta bloccando da sola");
	$p.blockingAlone = false;
	update($g);
end


rule "506.6"
/*
--- November 19, 2021 ---
506.6. Some spells state that they may be cast "only [before/after] [a particular point in the 
combat phase]," in which that point may be "attackers are declared," "blockers are declared," "the 
combat damage step," "the end of combat step," "the combat phase," or "combat."*/
dialect "mvel"
agenda-group "general"
when
	$g:Game(stage == Game.GAME_STAGE)
then
end


//BEGINNING OF COMBAT STEP
rule "507.1 choice"
/*
--- November 19, 2021 ---
First, if the game being played is a multiplayer game in which the active player's opponents don't all
 automatically become defending players, the active player chooses one of his or her opponents. That player becomes 
the defending player. This turn-based action doesn't use the stack. (See rule 506.2.)*/
agenda-group "general"
salience 200
dialect "mvel"
no-loop true
	when 
		$g: Game(stage == Game.GAME_STAGE, $ac : activePlayer, defendingPlayers.getSize()==0, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		$p: Player($id : id) from $ac.object
		eval($g.currentStep.getObject().name == "beginning of combat")
		eval($g.twoPlayerGame == false)
		//inserire condizione in cui tutti diventano defending
	then
		System.out.println("507.1 choice -> scelta del giocatore da attaccare");
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 5071;
		choice.choiceText = "Choose which player to attack";
		for(Player player : $g.nonActivePlayers){
			if(player.id != $id){
				choice.addOption(player.id, player.nickname);
			}
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $g.activePlayer.getObject().nickname + " chooses who wants to attack.");
		update($g);
end


rule "507.1 answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
salience 150
dialect "mvel"
no-loop true
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 5071)	
then
	boolean found = false;
	for(Player player : $g.priorityOrder) {
		if(player.id == $ca.idOptions.get(0))
		{
			$g.defendingPlayers.addObject(player);
			System.out.println("507.1 answer --> Il giocatore ha scelto chi attaccare");
			System.out.println("Il giocatore "+player.nickname+" � difensore");
			GameEngine.sendToNode("The player " + $g.activePlayer.getObject().nickname + " attacks "+player.nickname);
			found = true;
		}
	}
	if(!found){
		System.out.println("ERRORE 507.1 answer: Non � stato trovato avversario");
	}
	retract($ca);
	update($g);
end

rule "507.2"
	/*
	--- November 19, 2021 ---
	Second, the active player gets priority. (See rule 116, "Timing and Priority.")*/
	agenda-group "general"
	dialect "mvel"
	salience 50
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, defendingPlayers.getSize()!=0, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "beginning of combat")
		$p : Player() from $ac.object
	then
		$g.priorityMarker.movePointer($p);
		$g.stepTimeFrame = Game.DURING_TIME_FRAME;
		$g.phaseTimeFrame = Game.DURING_TIME_FRAME;
		System.out.println("507.2 Priority player: " + $g.priorityMarker.getObject().nickname + " Step declare attackers size: " + $g.stepDeclareAttackers.listReference.size());
		GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
		update($g);
end




//DECLARE ATTACKER
rule "508.1"
	/*
	--- November 19, 2021 ---
	508.1. First, the active player declares attackers. This turn-based action doesn't
	 use the stack. To declare attackers, the active player follows the steps below, in
	 order. If at any point during the declaration of attackers, the active player is unable
	 to comply with any of the steps listed below, the declaration is illegal; the game
	 returns to the moment before the declaration (see rule 717, NEW rule 720*/
	dialect "mvel"
	agenda-group "initialization"
	no-loop true
	when 
		$g: Game($sda: stepDeclareAttackers.listReference)
		eval($sda.size()==0)
	then
		System.out.println("508.1 -> creato stepDeclareAttacker");
		$sda.add("508.1a");
		$sda.add("508.1b");
		$sda.add("508.1c");
		$sda.add("508.1d");
		$sda.add("508.1e");
		$sda.add("508.1f");
		$sda.add("508.1g");
		$sda.add("508.1h");
		$sda.add("508.1i");
		$sda.add("508.1j");
		$sda.add("508.1k");
		$sda.add("508.1m");
		$sda.add("508.2");
		//$sda.add("508.3");
		$g.stepDeclareAttackers.next();
		update($g);	
end	


rule "508.1a choice"
/*
--- November 19, 2021 ---
508.1a. The active player chooses which creatures that he or she controls, 
if any, will attack. The chosen creatures must be untapped, and each one must 
either have haste or have been controlled by the active player continuously since 
the turn began.*/
agenda-group "general"
dialect "mvel"
salience 50
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.1a")
	$p: Player($id : id) from $ac.object
then
	System.out.println("508.1a choice --> Il giocatore sta scegliendo gli attaccanti");
	MakeChoice choice = new MakeChoice();
	choice.idChoice = 50811;//ATTENZIONE
	choice.choiceText = "Choose which creature will attack";
	boolean found = false;
	choice.addOption(-1, "No attack");
	
	/*
	Rule 702.3b. A creature with defender can't attack.
	*/
	for(Permanent permanent : $g.battleField) {
		if(permanent.idController == $id && !permanent.getStatus().isTapped() && !permanent.summoningSickness && permanent.cardType[0].contains("creature")){
			boolean nodefender = true;
		
			// Defender check of the selected permanent.
			if (permanent.checkKeywordAbility("Defender")){
				System.out.println("702.3b -> Card has Defender, can't attack !");
				nodefender = false;
			}	
			
			if (nodefender){
				choice.addOption(permanent.magicTargetId, permanent.getNameAsString());
				found = true;
			}
		}
	}
	if(found){
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
	} else {
		GameEngine.sendToNode("You have not creature to attack.");
		System.out.println("508.1a --> Il giocatore non ha creature per attaccare");
		$g.stepDeclareAttackers.next();
	}
	update($g);
end


rule "508.1a answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 50811)	
then
	System.out.println("508.1a risposta ricevuta");
	boolean attack = false;
	for(String option : $ca.idOptions ){
		for(Permanent permanent : $g.battleField){
			if(option == permanent.magicTargetId){
				attack = true;
				System.out.println("Creatura aggiunta");
				$g.attackingCreatures.listReference.add(permanent);
			}
		}
	}
	if(attack){
		System.out.println("Elenco attaccanti : "+$g.attackingCreatures.getSize());
		if($g.attackingCreatures.getSize()==1){
			$g.attackingCreatures.getObject(0).attackAlone = true;
			System.out.println($g.attackingCreatures.getObject(0).getNameAsString()+" attacca da sola")
		}
		for(Permanent permanent : $g.attackingCreatures.listReference){
			System.out.println( permanent.getNameAsString() +" sta attaccando");
		}
	} else {
		System.out.println("Il giocatore non vuole attaccare");
	}
	retract($ca);
	$g.stepDeclareAttackers.next();
	update($g);
end	
	


rule "508.1b base"
/*
--- November 19, 2021 ---
If the defending player controls any planeswalkers, or the game allows 
the active player to attack multiple other players, the active player announces 
which player or planeswalker each of the chosen creatures is attacking.*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME, possibleTarget.size() == 0)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.1b")
then
	System.out.println("508.1b --> Scelta dei target");
	for(Player player : $g.defendingPlayers.listReference){
		System.out.println("Aggiunto player target");
		$g.possibleTarget.add(player);
	}
	for(Permanent permanent : $g.battleField){
		if(permanent.cardType[0].contains("planeswalker")){
			for(Player player : $g.defendingPlayers.listReference){
				if(permanent.idController == player.id){
					System.out.println("Aggiunto planeswalker target");
					$g.possibleTarget.add(permanent);
				}
			}
		}
	}
	if($g.possibleTarget.size() == 1){
		for(Permanent creature : $g.attackingCreatures.listReference){
			creature.target = $g.possibleTarget[0];
			System.out.println("Un solo possibile bersaglio");
			System.out.println("Il bersaglio di "+creature.getNameAsString()+" � "+((Player)creature.target).nickname);
		}
		$g.stepDeclareAttackers.next();
	}
	update($g);
end	


rule "508.1b choice"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, possibleTarget.size() > 1, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.1b")
	$p: Player ($id : id) from $ac.object
then
	System.out.println("508.1b choice -> scelta dei bersagli");
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 50812;
		choice.choiceText = "Who does "+$g.attackingCreatures.object.getNameAsString()+" attack?";
		for(Target target : $g.possibleTarget){
			if(target instanceof Permanent){
				choice.addOption(((Permanent)target).getMagicTargetId(), "Planeswalker : "+((Permanent)target).getNameAsString());
			}
			if(target instanceof Player){
				choice.addOption(((Player)target).getId()*(-1), "Player : "+((Player)target).getNickname());
			}
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	} else {
		$g.attackingCreatures.toHead();
		$g.stepDeclareAttackers.next();
	}
end



rule "508.1b answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 50812)	
then
	System.out.println("508.1b risposta ricevuta");
	int risposta = Integer.parseInt($ca.idOptions.get(0));
	for(Target target : $g.possibleTarget){
		if(risposta<0 && target instanceof Player && ((Player)target).id == risposta*(-1)){
			$g.attackingCreatures.object.target = target;
			System.out.println("Il bersaglio di "+$g.attackingCreatures.object.getNameAsString()+" � "+((Player)$g.attackingCreatures.object.target).getNickname());
		}
		if(risposta>=0 && target instanceof Permanent && ((Permanent)target).magicTargetId == risposta){
			$g.attackingCreatures.object.target = target;
			System.out.println("Il bersaglio di "+$g.attackingCreatures.object.getNameAsString()+" � "+((Permanent)$g.attackingCreatures.object.target).getNameAsString());
		}
	}

	retract($ca);
	update($g);
end	



rule "508.1c"
/*
--- November 19, 2021 ---
508.1c. The active player checks each creature he or she controls to see whether it's affected by 
any restrictions (effects that say a creature can't attack, or that it can't attack unless some condition 
is met). If any restrictions are being disobeyed, the declaration of attackers is illegal.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1c")
then
	System.out.println("508.1c -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1d"
/*
--- November 19, 2021 ---
508.1d. The active player checks each creature he or she controls to see whether it's affected by any 
requirements (effects that say a creature must attack, or that it must attack if some condition is met). 
If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements 
that could be obeyed without disobeying any restrictions, the declaration of attackers is illegal. If a 
creature can't attack unless a player pays a cost, that player is not required to pay that cost, even if 
attacking with that creature would increase the number of requirements being obeyed.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1d")
then
	System.out.println("508.1d -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1e"
/*
--- November 19, 2021 ---
508.1e. If any of the chosen creatures have banding or a "bands with other" ability, the active 
player announces which creatures, if any, are banded with which. (See rule 702.21, "Banding.")*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1e")
then
	System.out.println("508.1e -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1f"
/*
--- November 19, 2021 ---
508.1f. The active player taps the chosen creatures. Tapping a creature when it's 
declared as an attacker isn't a cost; attacking simply causes creatures to become tapped.*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g:Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.1f")
then
	System.out.println("508.1f --> Creature attaccanti tappate");
	for(Permanent creature : $g.attackingCreatures.listReference) {
		creature.getStatus().setTapped(true);
		System.out.println(creature.getNameAsString()+" tappata");
	}
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1g"
/*
--- November 19, 2021 ---
508.1g. If there are any optional costs to attack with the chosen creatures (expressed as costs a player may pay "as" a creature attacks),
 the active player chooses which, if any, they will pay.
*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1g")
then
	System.out.println("508.1g -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end

rule "508.1h"
/*
--- November 19, 2021 ---
508.1h. If any of the chosen creatures require paying costs to attack, the active player determines the 
total cost to attack. Costs may include paying mana, tapping permanents, sacrificing permanents, discarding 
cards, and so on. Once the total cost is determined, it becomes "locked in." If effects would change the 
total cost after this time, ignore this change.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1h")
then
	System.out.println("508.1h -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1i"
/*
--- November 19, 2021 ---
508.1i. If any of the costs require mana, the active player then has a 
chance to activate mana abilities (see rule 605, "Mana Abilities").*/
agenda-group "general"
dialect "mvel"
no-loop true
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer)
	eval($g.stepDeclareAttackers.getObject() == "508.1i")
	$p: Player($id : id) from $ac.object
	//TODO: se il costo richiede mana, per ora utilizza un if nel then per saltare questa fase
then
	if($g.attackingCreatures.getSize()>0){
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 50818;
		choice.choiceText = "Do you want to activate Mana Abilites?";
		choice.addOption(1, "Yes");
		choice.addOption(2, "No");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
		System.out.println("508.1i -> The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
	} else {
		$g.stepDeclareAttackers.next();
	}
	update($g);
end


rule "508.1i answerHandlerNo"
/*--- November 19, 2021 ---
*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer)
	$p: Player($id : id)
	$ca: ChoiceAnswer(idChoice == 50818, idOptions.get(0) == 2)	
then
	GameEngine.sendToNode($p.nickname+" doesn't want to activate Mana Abilities");
	System.out.println("508.1i -> "+$p.nickname+" non vuole attivare Mana Ability");
	$g.stepDeclareAttackers.next();
	retract($ca);
	update($g);
end


rule "508.1j"
/*
--- November 19, 2021 ---
508.1j. Once the player has enough mana in his or her mana pool, he or she pays all costs 
in any order. Partial payments are not allowed.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1j")
then
	System.out.println("508.1j -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1k"
/*
--- November 19, 2021 ---
508.1k. Each chosen creature still controlled by the active player becomes an 
attacking creature. It remains an attacking creature until it's removed from 
combat or the combat phase ends, whichever comes first. See rule 506.4.*/
agenda-group "general"
dialect "mvel"
salience 50
no-loop true
when
	$g: Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.1k")
	$p: Player($id : id) from $ac.object
then
	System.out.println("508.1k --> le creature diventano attacking");
	for(Permanent creature : $g.attackingCreatures.listReference){
		if(creature.idController == $p.id){
			creature.attacking = true;
			System.out.println(creature.getNameAsString()+" diventa attaccante");
		} else {
			$g.attackingCreatures.remove(creature);
		}
	}
	System.out.println("Fine dichiarazione");
	$g.stepDeclareAttackers.next();
	update($g);
end


rule "508.1m"
/*
--- November 19, 2021 ---
508.1m. Any abilities that trigger on attackers being declared trigger.
*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareAttackers.getObject() == "508.1m")
then
	System.out.println("508.1m -> next");
	$g.stepDeclareAttackers.next();
	update($g);
end

rule "508.2"
/*
--- November 19, 2021 ---
Second, the active player gets priority. (See rule 116, "Timing and Priority.")*/
agenda-group "general"
dialect "mvel"
salience 50

when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
	eval($g.stepDeclareAttackers.getObject() == "508.2")
	$p : Player() from $ac.object
then
	$g.priorityMarker.movePointer($p);
	$g.stepTimeFrame = Game.DURING_TIME_FRAME;
	System.out.println("508.2 Priority player: " + $g.priorityMarker.getObject().nickname);
	GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
	update($g);
end

rule "508.2a"
	/* 
	--- November 19, 2021 ---
	Abilities that trigger on a creature attacking trigger only 
		at the point the creature is declared as an attacker. 
		They will not trigger if a creature attacks and then that 
		creature's characteristics change to match the ability's trigger condition. */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end

rule "508.2b"
	/* 
	--- November 19, 2021 ---
	Any abilities that triggered on attackers being declared or 
		that triggered during the process described in rules 508.1 
		are put onto the stack before the active player gets priority; 
		the order in which they triggered doesn't matter. 
		(See rule 603, "Handling Triggered Abilities.") */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "508.3"
	/* 
	--- November 19, 2021 ---
	508.3. Triggered abilities that trigger on attackers being declared may have different trigger conditions.*/
	dialect "mvel"
	agenda-group "general"
	when
	then
end 


rule "508.3a"
	/*
	--- November 19, 2021 ---
	508.3a. An ability that reads "Whenever [a creature] attacks, . . ." triggers if that creature is declared as an attacker. Similarly, "Whenever [a creature] attacks [a player or planeswalker], . . ." triggers if that creature is declared as an attacker attacking that player or planeswalker. Such abilities won't trigger if a creature is put onto the battlefield attacking.
	*/
	when
	then
end

rule "508.3b"
	/*
	--- November 19, 2021 ---
	508.3b. An ability that reads "Whenever [a player or planeswalker] is attacked, . . ." triggers if one or more creatures are declared as attackers attacking that player or planeswalker.
	It won't trigger if a creature is put onto the battlefield attacking that player or planeswalker.*/
	when
	then
end

rule "508.3c"
	/* 	
	--- November 19, 2021 ---
	508.3c. An ability that reads "Whenever [a player] attacks with [a creature], . . ." triggers whenever a creature that player controls is declared as an attacker. */
	when
	
	then

end

rule "508.3d"
	/* 	
	--- November 19, 2021 ---
	508.3d. An ability that reads "Whenever [a creature] attacks and isn't blocked, . . ." triggers during the declare blockers step, not the declare attackers step. See rule 509.5g. */
	when
	
	then

end

rule "508.4"
	/* 
	--- November 19, 2021 ---
	508.4. If a creature is put onto the battlefield attacking, its controller chooses which defending player or which planeswalker a defending player 
	controls it's attacking as it enters the battlefield (unless the effect that put it onto the battlefield specifies what it's attacking).
	Such creatures are "attacking" but, for the purposes of trigger events and effects, they never "attacked."*/
	dialect "mvel"
	agenda-group "general"
	when
	then
end 

rule "508.4a"
	/*
	--- November 19, 2021 ---
	508.4a. If the effect that puts a creature onto the battlefield attacking specifies it's attacking a certain player, and that player is no longer in the game 
	when the effect resolves, the creature is put onto the battlefield but is never considered an attacking creature. The same is true if the effect specifies 
	a creature is put onto the battlefield attacking a planeswalker and that planeswalker is no longer on the battlefield or is no longer a planeswalker 
	when the effect resolves.
	*/
	when
	then
end

rule "508.4b"
	/* 	
	--- November 19, 2021 ---
	508.4b. A creature that's put onto the battlefield attacking isn't affected by requirements or restrictions that apply to the declaration of attackers. */
	when
	
	then

end


rule "508.5"
	/* 
	--- November 19, 2021 ---
		If an ability of an attacking creature refers to a defending player, or a spell or ability refers to both an attacking creature and 
		a defending player, then unless otherwise specified, the defending player it's referring to is the player that creature is attacking, 
		or the controller of the planeswalker that creature is attacking. If that creature is no longer attacking, the defending player it's 
		referring to is the player that creature was attacking before it was removed from combat or the controller of the planeswalker that 
		creature was attacking before it was removed from combat.
	*/

	agenda-group "general"
	dialect "mvel"
	when
		$g:Game(stage == Game.GAME_STAGE)
	then
end


rule "508.5a"
	/*
	--- November 19, 2021 ---
	508.5a. In a multiplayer game, any rule, object, or effect that refers to a "defending player" refers to one specific defending player, not to 
	all of the defending players. If a spell or ability could apply to multiple attacking creatures, the appropriate defending player is 
	individually determined for each of those attacking creatures. If there are multiple defending players that could be chosen, the controller 
	of the spell or ability chooses one.*/
	when
	then
end



rule "508.8"
/*
--- November 19, 2021 ---
508.8. If no creatures are declared as attackers or put onto the battlefield 
attacking, skip the declare blockers and combat damage steps.*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.END_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare attackers")
then
	if($g.attackingCreatures.listReference.size() == 0){
		System.out.println("508.8 -> Salto declare blocker e damage");
		for(Step step : $g.currentStep.listReference){
			if(step.name == "declare blockers" || step.name == "combat damage"){
				step.toSkip = true;
			}
		}
	} else {
		System.out.println("508.8 -> non saltare blocker e damage");
	}
	update($g);
end



//DECLARE BLOCKER
rule "509.1"
/*
--- November 19, 2021 ---
509.1: First, the defending player declares blockers. This turn-based action doesn't use 
the stack. To declare blockers, the defending player follows the steps below, in order. 
If at any point during the declaration of blockers, the defending player is unable to 
comply with any of the steps listed below, the declaration is illegal; the game returns 
to the moment before the declaration*/
agenda-group "initialization"
dialect "mvel"
no-loop true
when 
	$g: Game($sdb: stepDeclareBlockers.listReference)
	eval($sdb.size()==0)
then
	$sdb.add("509.1a choice");
	$sdb.add("canBlock");
	$sdb.add("509.1a second choice");
	$sdb.add("isBlockValid");
	$sdb.add("509.1b");
	$sdb.add("509.1c");
	$sdb.add("509.1d");
	$sdb.add("509.1e");
	$sdb.add("509.1f");
	$sdb.add("509.1gh");
	$sdb.add("509.2");
	$sdb.add("509.3");
	$sdb.add("509.4");
	// sdb.add("509.5");
	$g.stepDeclareBlockers.next();
	update($g);	
end	


rule "509.1a choice"
/*
--- November 19, 2021 ---
509.1a. The defending player chooses which creatures that he or she controls, if any, 
will block. The chosen creatures must be untapped. For each of the chosen creatures, the 
defending player chooses one creature for it to block that's attacking him, her, or a 
planeswalker he or she controls.*/
agenda-group "general"
dialect "mvel"
salience 50
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.1a choice")
then
	Player defender = $g.defendingPlayers.next();
	int id = defender.id;
	System.out.println("509.1a choice --> Il giocatore "+defender.nickname+"sta scegliendo i bloccanti");
	$g.attackingCreatures.movePointer(0);
	MakeChoice choice = new MakeChoice();
	choice.idChoice = 50911;//ATTENZIONE
	choice.choiceText = "Choose which creature will block";
	boolean found = false;
	choice.addOption(-1, "No block");
	for(Permanent permanent : $g.battleField) {
		if(permanent.idController == id && !permanent.getStatus().isTapped() && permanent.cardType[0].contains("creature")){
			choice.addOption(permanent.magicTargetId, permanent.getNameAsString());
			found = true;
		}
	}
	if(found){
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, id);
	} else {
		GameEngine.sendToNode(defender.nickname+" has not creature to block.");
		System.out.println("509.1a --> "+defender.nickname+" non ha creature per bloccare");
		$g.stepDeclareBlockers.movePointer("509.1b");
	}
	update($g);
end


rule "509.1a answerHandler"
/*
--- November 19, 2021 ---
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 50911)	
then
	System.out.println("509.1a risposta ricevuta");
	boolean block = false;
	for(String option : $ca.idOptions ){
		// Dichiarazione dei bloccanti
		for(Permanent permanent : $g.battleField){
			if(option == permanent.magicTargetId){
				block = true;
				permanent.attackersICanBlock = $g.attackingCreatures.listReference;
				$g.blockingCreatures.addObject(permanent);
				System.out.println( permanent.getNameAsString() +" sta bloccando");
			}
		}
	}
	if(block){
		if($g.blockingCreatures.getSize()==1){
			$g.blockingCreatures.getObject(0).blockAlone = true;
			System.out.println($g.blockingCreatures.getObject(0).getNameAsString()+" blocca da sola")
		}
		System.out.println("509.1a aH --> "+$g.defendingPlayers.object.nickname+" sta bloccando");
		$g.stepDeclareBlockers.next();
	} else {
		// Nessun bloccante dichiarato
		System.out.println("509.1a aH --> "+$g.defendingPlayers.object.nickname+" non vuole bloccare");
		$g.stepDeclareBlockers.movePointer("509.1b");
	}
	retract($ca);
	update($g);
end	


rule "canBlock"
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, 
			$de : defendingPlayers, 
			$g.blockingCreatures.getSize()>0, 
			stepTimeFrame == Game.BEGIN_TIME_FRAME,
			$sce: stepCheckEvasionAbility.listReference)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "canBlock")
	eval($sce.size() == 0)
	$p: Player($id : id) from $de.object
then
	System.out.println("canBlock")
	$sce.add("702.28b part 2"); // Shadow
	// ...
	$sce.add("canBlock end");
	$g.stepCheckEvasionAbility.next();
	update($g);	
end

rule "canBlock end"
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE,
			stepCheckEvasionAbility.listReference.size() > 0,
			$sce: stepCheckEvasionAbility.listReference)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepCheckEvasionAbility.getObject() == "canBlock end")
then
	System.out.println("canBlock end!")
	// Reset stepCheckEvasionAbility
	$g.resetStepCheckEvasionAbility();
	// Proseguo con la dichiarazione dei bloccanti
	$g.stepDeclareBlockers.next();
	update($g);	
end

rule "509.1a second choice"
/*
--- November 19, 2021 ---
*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers, $g.blockingCreatures.getSize()>0, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.1a second choice")
	$p: Player($id : id) from $de.object
then
	System.out.println("509.1a second choice -> scelta dei bersagli");
	if($g.blockingCreatures.hasNext()){
		bloccante = $g.blockingCreatures.next();
		// se il bloccante può bloccare almeno 1 attaccante ...
		if (bloccante.attackersICanBlock.size() > 0) {
			MakeChoice choice = new MakeChoice();
			choice.idChoice = 509111;
			choice.choiceText = "Who does "+ bloccante.getNameAsString() + " block?";
			// ... il giocatore sceglie quale attaccante bloccare tra quelli cahe possono essere effettivamente bloccati
			for(Permanent permanent : bloccante.attackersICanBlock){
				choice.addOption(permanent.getMagicTargetId(), permanent.getNameAsString());
			}
			GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		} 
		// altrimenti ...
		else {
			// ... il permanente non può bloccare nessun attaccante
			GameEngine.sendToNode(bloccante.getNameAsString() + " non può bloccare nessun attaccante");
			// lo rimuovo dalla lista delle creature bloccanti
			$g.blockingCreatures.remove(bloccante);
			GameEngine.sendToNode(bloccante.getNameAsString() + " viene rimosso dalla lista dei bloccanti");
			// torno indietro di uno step nella lista dei bloccanti
			currentIndex = $g.blockingCreatures.index;
			if (currentIndex == 0) {
				$g.blockingCreatures.toHead();
			} else {
				$g.blockingCreatures.movePointer(currentIndex - 1);
			}		
			
			if ($g.blockingCreatures.getSize() == 0){
				$g.stepDeclareBlockers.next();
			}	
		}
	} else {
		$g.blockingCreatures.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.1a second answerHandler"
/*
--- November 19, 2021 ---
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 509111)	
then
	System.out.println("509.1a seconda risposta ricevuta");
	for(Permanent permanent : $g.attackingCreatures.listReference){
		if(permanent.magicTargetId == $ca.idOptions.get(0)){
			 $g.blockingCreatures.object.blockedCreatures.addObject(permanent);
		}
	}
	retract($ca);
	update($g);
end	


// Controllo se i blocchi sono validi
rule "isBlockValid"
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, 
			$de : defendingPlayers, 
			stepTimeFrame == Game.BEGIN_TIME_FRAME,
			$sce: stepCheckEvasionAbility.listReference)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "isBlockValid")
	eval($sce.size() == 0)
	$p: Player($id : id) from $de.object
then
	System.out.println("isBlockValid");
	// Resetto il flag di validità dei blocchi
	$g.blockValid = true;
	if($g.blockingCreatures.getSize() == 0) {
		// se non ci sono più bloccanti, non è necessario effettuare i controlli
		$g.stepDeclareBlockers.next();
	} else {
	    $sce.add("702.9b"); //flying
	    $sce.add("702.13b"); //Intimidate
	    $sce.add("702.14c"); //Landwalk
		$sce.add("702.28b part 1"); // Shadow
		$sce.add("702.31b"); //Horsemanship
		$sce.add("702.36b"); //Fear
		$sce.add("702.111b"); //menace
		$sce.add("702.118b"); //skulk
		// ...
		$sce.add("isBlockValid end");
		$g.stepCheckEvasionAbility.next();
	}
	update($g);	
end

rule "isBlockValid end"
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE,
			stepCheckEvasionAbility.listReference.size() > 0,
			$sce: stepCheckEvasionAbility.listReference)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepCheckEvasionAbility.getObject() == "isBlockValid end")
then
	System.out.println("isBlockValid end!");
	// Reset stepCheckEvasionAbility
	$g.resetStepCheckEvasionAbility();
	// Se c'è almeno 1 blocco NON Valido ...
	if (! $g.blockValid) {
		// ... ricomincio la dichiarazione dei bloccanti
		$g.stepDeclareBlockers.movePointer(0);
		// per ogni bloccante dichiarato ...
		for (Permanent blocker : $g.blockingCreatures.listReference) {
		    // ... resetto la lista degli attaccanti bloccati
			blocker.resetBlockedCreatures();
		}
		// resetto la lista dei bloccanti
		$g.blockingCreatures.listReference.clear();
		$g.blockingCreatures.toHead();
		// resetto il defending player
		$g.defendingPlayers.toHead();
		
		GameEngine.sendToNode("Il difensore ha dichiarato un blocco illegale.");
	} else {
		// ... proseguo con la dichiarazione dei bloccanti
		$g.stepDeclareBlockers.next();
	}
	update($g);	
end

rule "509.1b"
/*
--- November 19, 2021 ---
509.1b. The defending player checks each creature he or she controls to see whether it's affected by 
any restrictions (effects that say a creature can't block, or that it can't block unless some condition 
is met). If any restrictions are being disobeyed, the declaration of blockers is illegal. A restriction 
may be created by an evasion ability (a static ability an attacking creature has that restricts what can 
block it). If an attacking creature gains or loses an evasion ability after a legal block has been declared, 
it doesn't affect that block. Different evasion abilities are cumulative.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareBlockers.getObject() == "509.1b")
then
	System.out.println("509.1b -> next");
	$g.stepDeclareBlockers.next();
	update($g);
end


rule "509.1c"
/*
--- November 19, 2021 ---
509.1c. The defending player checks each creature he or she controls to see whether it's affected by 
any requirements (effects that say a creature must block, or that it must block if some condition is met). 
If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements 
that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a 
creature can't block unless a player pays a cost, that player is not required to pay that cost, even if 
blocking with that creature would increase the number of requirements being obeyed.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareBlockers.getObject() == "509.1c")
then
	System.out.println("509.1c -> next");
	$g.stepDeclareBlockers.next();
	update($g);
end


rule "509.1d"
/*
--- November 19, 2021 ---
509.1d. If any of the chosen creatures require paying costs to block, the defending player determines 
the total cost to block. Costs may include paying mana, tapping permanents, sacrificing permanents, 
discarding cards, and so on. Once the total cost is determined, it becomes "locked in." If effects would 
change the total cost after this time, ignore this change.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareBlockers.getObject() == "509.1d")
then
	System.out.println("509.1d -> next");
	$g.stepDeclareBlockers.next();
	update($g);
end


rule "509.1e"
/*
--- November 19, 2021 ---
509.1e. If any of the costs require mana, the defending player then has a chance to 
activate mana abilities (see rule 605, "Mana Abilities").
*/
agenda-group "general"
dialect "mvel"
no-loop true
when 
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers)
	eval($g.stepDeclareBlockers.getObject() == "509.1e")
	$p: Player($id : id) from $de.object
then
	if($g.blockingCreatures.getSize()>0){
	MakeChoice choice = new MakeChoice();
	choice.idChoice = 50915;
	choice.choiceText = "Do you want to activate Mana Abilites?";
	choice.addOption(1, "Yes");
	choice.addOption(2, "No");
	GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	GameEngine.sendToNode("The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
	System.out.println("509.1e -> The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
	} else {
		System.out.println("509.1e -> next");
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.1e answerHandlerNo"
/*
--- November 19, 2021 ---
*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers)
	$p: Player($id : id) from $de.object
	$ca: ChoiceAnswer(idChoice == 50915, idOptions.get(0) == 2)	
then
	GameEngine.sendToNode($p.nickname+" doesn't want to activate Mana Abilities");
	System.out.println("509.1e -> "+$p.nickname+" non vuole attivare Mana Ability");
	$g.stepDeclareBlockers.next();
	retract($ca);
	update($g);
end


rule "509.1f"
/*
--- November 19, 2021 ---
509.1f. Once the player has enough mana in his or her mana pool, he or she pays all costs in any order. 
Partial payments are not allowed.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
	eval($g.stepDeclareBlockers.getObject() == "509.1f")
then
	System.out.println("509.1f -> next");
	$g.stepDeclareBlockers.next();
	update($g);
end


rule "509.1g & 509.1h"
/*
--- November 19, 2021 ---
509.1g. Each chosen creature still controlled by the defending player becomes a blocking 
creature. Each one is blocking the attacking creatures chosen for it. It remains a blocking 
creature until it's removed from combat or the combat phase ends, whichever comes 
first. See rule 506.4.
/*
/*
--- November 19, 2021 ---
509.1h. An attacking creature with one or more creatures declared as blockers for it becomes 
a blocked creature; one with no creatures declared as blockers for it becomes an unblocked 
creature. This remains unchanged until the creature is removed from combat, an effect says 
that it becomes blocked or unblocked, or the combat phase ends, whichever comes first. A 
creature remains blocked even if all the creatures blocking it are removed from combat.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.1gh")
	$p: Player($id : id) from $de.object
then
	System.out.println("509.1gh -> Le creature diventano bloccanti");
	for(Permanent permanent : $g.blockingCreatures.listReference){
		if(permanent.idController == $id){
			permanent.blocking = true;
			for(Permanent attackerBlocked : permanent.blockedCreatures.listReference){
				attackerBlocked.blocked = true;
				attackerBlocked.blockedBy.addObject(permanent);
			}
		} else {
			permanent.blockedCreatures.listReference.clear();
			permanent.blockedCreatures.toHead();
			$g.blockingCreatures.remove(permanent);
		}
	}
	if($de.hasNext()){
		$g.stepDeclareBlockers.movePointer("509.1a");
	} else {
		$de.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.2 prepare"
//Per funzionare le successive 509.2 devono avere index > -1, cio� devono puntare a un oggetto
/*
--- November 19, 2021 ---
509.2. Second, for each attacking creature that's become blocked, the active 
player announces that creature's damage assignment order, which consists of the 
creatures blocking it in an order of that player's choice. (During the combat 
damage step, an attacking creature can't assign combat damage to a creature that's 
blocking it unless each creature ahead of that blocking creature in its order is 
assigned lethal damage.) This turn-based action doesn't use the stack.*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g: Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.2")
	eval($g.attackingCreatures.index == -1)
then
	System.out.println("509.2 prepare attackingCreatures");
	if($g.attackingCreatures.getSize()>0){
		$g.attackingCreatures.movePointer(0);
	} else {
		System.out.println("509.2 -> Non ci sono creature attaccanti");
		$g.stepDeclareBlockers.next();
	}
	update($g);
end
	
	
rule "509.2 noblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.2")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()==0)
	$p: Player($id : id) from $ac.object
then
	Permanent attacker = $g.attackingCreatures.object;
	System.out.println("509.2 -> "+attacker.getNameAsString()+" non � bloccato");
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else {
		$g.attackingCreatures.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.2 1block"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.2")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()==1)
	$p: Player($id : id) from $ac.object
then
	Permanent attacker = $g.attackingCreatures.object;
	System.out.println(attacker.getNameAsString()+" � bloccato da una sola creatura");
	attacker.blockedBy.next();
	attacker.damageAssignmentOrder.addObject(attacker.blockedBy.object);
	
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else {
		$g.attackingCreatures.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.2 moreblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g: Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.2")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()>1)
	$p: Player($id : id) from $ac.object
then
	Permanent attacker = $g.attackingCreatures.object;
	System.out.println(attacker.getNameAsString()+" � bloccato da pi� creature");
	if(attacker.blockedBy.hasNext()){
		attacker.blockedBy.next();
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 5092;
		int ordine = attacker.blockedBy.index+1;
		choice.choiceText = "Damage Assignment Order of "+attacker.getNameAsString()+": number "+ordine;
		for(Permanent blocker : attacker.blockedBy.listReference){
			if(!attacker.damageAssignmentOrder.listReference.contains(blocker)){
				choice.addOption(blocker.magicTargetId,blocker.getNameAsString());
			}
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	} else if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else{
		$g.attackingCreatures.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.2 answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 5092)
then
	System.out.println("509.2 answer --> Assegnamento ordine attaccanti");
	Permanent attacker = $g.attackingCreatures.object;
	for(Permanent blocker : attacker.blockedBy.listReference){
		if($ca.idOptions.get(0) == blocker.magicTargetId){
			attacker.damageAssignmentOrder.addObject(blocker);
		}
	}
	retract($ca);
	update($g);
end


rule "509.3 prepare"
/*
--- November 19, 2021 ---
509.3. Third, for each blocking creature, the defending player announces that 
creature's damage assignment order, which consists of the creatures it's blocking 
in an order of that player's choice. (During the combat damage step, a blocking 
creature can't assign combat damage to a creature it's blocking unless each 
creature ahead of that blocked creature in its order is assigned lethal damage.) 
This turn-based action doesn't use the stack.*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.3")
	eval($g.blockingCreatures.index == -1)
then
	$g.defendingPlayers.next();
	System.out.println("509.3 prepare blockingCreatures");
	if($g.blockingCreatures.getSize()>0){
		$g.blockingCreatures.movePointer(0);
	} else {
		System.out.println("509.3 -> Non ci sono creature bloccanti");
		$g.defendingPlayers.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.3 not right defender"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.3")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.idController != $g.defendingPlayers.object.id);
then
	if($g.blockingCreatures.hasNext()){
		System.out.println("509.3 not rd -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("509.3 not rd -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("509.3 not rd -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.3 noblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.3")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()==0)
then
	Permanent blocker = $g.blockingCreatures.object;
	System.out.println(blocker.getNameAsString()+" non sta bloccando nessuno");
	if($g.blockingCreatures.hasNext()){
		System.out.println("509.3 noblock -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("509.3 noblock -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("509.3 noblock -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.3 1block"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.3")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()==1)
then
	Permanent blocker = $g.blockingCreatures.object;
	System.out.println(blocker.getNameAsString()+" sta bloccando una sola creatura");
	blocker.blockedCreatures.next();
	blocker.damageAssignmentOrder.addObject(blocker.blockedCreatures.object);
	
	if($g.blockingCreatures.hasNext()){
		System.out.println("509.3 1block -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("509.3 1block -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("509.3 1block -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.3 moreblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
no-loop true
when
	$g: Game(stage == Game.GAME_STAGE, $de : defendingPlayers, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "declare blockers")
	eval($g.stepDeclareBlockers.getObject() == "509.3")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()>1)
	$p: Player($id : id) from $de.object
then
	Permanent blocker = $g.blockingCreatures.object;
	System.out.println(blocker.getNameAsString()+" sta bloccando pi� creature");
	if(blocker.blockedCreatures.hasNext()){
		blocker.blockedCreatures.next();
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 5092;
		int ordine = blocker.blockedCreatures.index+1;
		choice.choiceText = "Damage Assignment Order of "+blocker.getNameAsString()+": number "+ordine;
		for(Permanent attacker : blocker.blockedCreatures.listReference){
			if(!blocker.damageAssignmentOrder.listReference.contains(attacker)){
				choice.addOption(attacker.magicTargetId,attacker.getNameAsString());
			}
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	} else if($g.blockingCreatures.hasNext()){
		System.out.println("509.3 moreblock -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("509.3 moreblock -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("509.3 moreblock -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepDeclareBlockers.next();
	}
	update($g);
end


rule "509.3 answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 5093)
then
	System.out.println("509.3 answer --> Assegnamento ordine bloccanti");
	Permanent attacker = $g.attackingCreatures.object;
	for(Permanent blocker : attacker.blockedBy.listReference){
		if($ca.idOptions.get(0) == blocker.magicTargetId){
			attacker.damageAssignmentOrder.addObject(blocker);
		}
	}
	update($g);
end

rule "509.4"
	/* 
	--- November 19, 2021 ---
	509.4. Fourth, the active player gets priority. (See rule 116, "Timing and Priority.") */
	agenda-group "general"
	dialect "mvel"
	salience 50
	
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepDeclareBlockers.getObject() == "509.4")
		$p : Player() from $ac.object
	then
		$g.priorityMarker.movePointer($p);
		$g.stepTimeFrame = Game.DURING_TIME_FRAME;
		System.out.println("509.4 Priority player: " + $g.priorityMarker.getObject().nickname);
		GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
		update($g);
end

rule "509.4a"
	/* 
	--- November 19, 2021 ---
	509.4a. Any abilities that triggered on blockers being declared or that triggered during the process described in rules 509.1-3 are put onto 
	the stack before the active player gets priority; the order in which they triggered doesn't matter. (See rule 603, "Handling Triggered Abilities.")*/
	when
	then
end

rule "509.5"
	/* 
	--- November 19, 2021 ---
	509.5. Triggered abilities that trigger during the declare blockers step may have different trigger conditions. */
	agenda-group "general"
	dialect "mvel"
	
	when
		
	then
		
end	

rule "509.6"
/*
--- November 19, 2021 ---
509.6. If a spell or ability causes a creature on the battlefield to block an attacking creature, 
the active player announces the blocking creature's placement in the attacking creature's damage assignment 
order. The relative order among the remaining blocking creatures is unchanged. Then the defending player 
announces the attacking creature's placement in the blocking creature's damage assignment order. The relative 
order among the remaining attacking creatures is unchanged. This is done as part of the blocking effect.*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
then
end


rule "509.7"
/*
--- November 19, 2021 ---
509.7. If a creature is put onto the battlefield blocking, its controller chooses which attacking 
creature it's blocking as it enters the battlefield (unless the effect that put it onto the battlefield 
specifies what it's blocking), then the active player announces the new creature's placement in the blocked 
creature's damage assignment order. The relative order among the remaining blocking creatures is unchanged. 
A creature put onto the battlefield this way is "blocking" but, for the purposes of trigger events and 
effects, it never "blocked."*/
agenda-group "general"
dialect "mvel"
when
	$g:Game(stage == Game.GAME_STAGE)
then
end


//COMBAT DAMAGE STEP
rule "510.1"
/*
--- November 19, 2021 ---
510.1. First, the active player announces how each attacking creature 
assigns its combat damage, then the defending player announces how each 
blocking creature assigns its combat damage. This turn-based action doesn't 
use the stack. A player assigns a creature's combat damage according to the 
following rules:*/
agenda-group "initialization"
dialect "mvel"
no-loop true
when 
	$g: Game($scd: stepCombatDamage.listReference)
	eval($scd.size()==0)
then
	System.out.println("510.1 -> Aggiunti step per il combat damage");
	// aggiungere prima una regola che controlla se c'� o non c'� double/first, se c'� crea la lista con queste 3 aggiunte	
	$scd.add("510.1a");
	$scd.add("510.1bc");
	//$scd.add("702.2b");
	$scd.add("510.1d");
	//$scd.add("510.1e");
	$scd.add("510.2");
	$scd.add("510.3");
	//$scd.add("510.4");
	$g.stepCombatDamage.next();
	update($g);	
end	


rule "510.1a"
/*
--- November 19, 2021 ---		
510.1a. Each attacking creature and each blocking creature assigns combat 
damage equal to its power. Creatures that would assign 0 or less damage this 
way don't assign combat damage at all.*/
agenda-group "general"
dialect "mvel"
no-loop true
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1a")
then
	System.out.println("510.1a -> calcola combat damage da power");
	int powerInt = 0;

	for(Permanent attacker : $g.attackingCreatures.listReference){
		if($g.firstStrikeAttaking == true && !((!attacker.checkKeywordAbility("First strike") && attacker.checkKeywordAbility("Double strike"))||((attacker.checkKeywordAbility("First strike") && !attacker.checkKeywordAbility("Double strike"))))){
			attacker.damageToAssign = 0;
			System.out.println(attacker.getNameAsString()+" non fa danni perchè non ha First/Double Strike");
		} else {
			powerInt = Integer.parseInt(attacker.power[0]);
			if(powerInt<=0){
				attacker.damageToAssign = 0;
				System.out.println(attacker.getNameAsString()+" ha "+attacker.damageToAssign+" danni");
			} else {
				attacker.damageToAssign = powerInt;
				System.out.println(attacker.getNameAsString()+" ha "+attacker.damageToAssign+" danni");
			}
		}
	}
	
	for(Permanent blocker : $g.blockingCreatures.listReference){
		if($g.notRedoDamage == false && blocker.checkKeywordAbility("First strike")){
			blocker.damageToAssign = 0;
			System.out.println(blocker.getNameAsString()+" non fa danni da difensore perchè li ha fatti prima con First Strike");
		} else {
			if($g.firstStrikeAttaking == true && !((!blocker.checkKeywordAbility("First strike") && blocker.checkKeywordAbility("Double strike"))||((blocker.checkKeywordAbility("First strike") && !blocker.checkKeywordAbility("Double strike"))))){
				blocker.damageToAssign = 0;
				System.out.println(blocker.getNameAsString()+" non fa danni da difensore perchè non ha First/Double Strike");
			} else {
				powerInt = Integer.parseInt(blocker.power[0]);
				if(powerInt<=0){
					blocker.damageToAssign = 0;
					System.out.println(blocker.getNameAsString()+" ha "+blocker.damageToAssign+" danni");
				} else {
					blocker.damageToAssign = powerInt;
					System.out.println(blocker.getNameAsString()+" ha "+blocker.damageToAssign+" danni");
				}
			}
		}
	}

	if($g.attackingCreatures.listReference.size() > 0){
		$g.attackingCreatures.movePointer(0);
	}
	
	System.out.println("510.1a -> indice attuale di step: "+ $g.currentStep.getObject().name);
	System.out.println("510.1a -> step addizionale? "+ $g.currentStep.getObject().additional);
	$g.stepCombatDamage.next();
	update($g);	
end	


rule "510.1b prepare"
/*
--- November 19, 2021 ---
510.1b. An unblocked creature assigns its combat damage to the player or 
planeswalker it's attacking. If it isn't currently attacking anything (if, 
for example, it was attacking a planeswalker that has left the battlefield), 
it assigns no combat damage.*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1bc")
	eval($g.attackingCreatures.index == -1)
then
	System.out.println("510.1b prepare");
	if($g.attackingCreatures.getSize()>0){
		$g.attackingCreatures.movePointer(0);
	} else {
		System.out.println("Non ci sono pi� creature per attaccare");
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1b unblocked"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1bc")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blocked == false)
then
	Permanent attacker = $g.attackingCreatures.object;
	System.out.println("510.1b -> assegnamento danni");
	if(attacker.target == null){
		System.out.println(attacker.getNameAsString()+" non ha pi� un bersaglio");
	}else if(attacker.target instanceof Player){
		Player bersaglioPlayer = ((Player)attacker.target);
		System.out.println(bersaglioPlayer.nickname+" ha "+bersaglioPlayer.combatDamage+" combat damage");
		System.out.println(attacker.getNameAsString()+" ha "+attacker.damageToAssign+" danni da assegnare");
		bersaglioPlayer.combatDamage = bersaglioPlayer.combatDamage + attacker.damageToAssign;
		System.out.println("Ora "+bersaglioPlayer.nickname+" ha "+bersaglioPlayer.combatDamage+" combat damage");
	} else if(attacker.target instanceof Permanent){
		Permanent bersaglioPermanent = ((Permanent)attacker.target);
		System.out.println(bersaglioPermanent.getNameAsString()+" ha "+bersaglioPermanent.combatDamage+" combat damage");
		System.out.println(attacker.getNameAsString()+" ha "+attacker.damageToAssign+" danni da assegnare");
		bersaglioPermanent.combatDamage = bersaglioPermanent.combatDamage + attacker.damageToAssign;
		System.out.println("Ora "+bersaglioPermanent.getNameAsString()+" ha "+bersaglioPermanent.combatDamage+" combat damage");
	}
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else {
		$g.attackingCreatures.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);	
end	


rule "510.1c noblock"
/*
--- November 19, 2021 ---
510.1c. A blocked creature assigns its combat damage to the creatures blocking it. 
If no creatures are currently blocking it (if, for example, they were destroyed or 
removed from combat), it assigns no combat damage. If exactly one creature is blocking 
it, it assigns all its combat damage to that creature. If two or more creatures are 
blocking it, it assigns its combat damage to those creatures according to the damage 
assignment order announced for it. This may allow the blocked creature to divide its 
combat damage. However, it can't assign combat damage to a creature that's blocking 
it unless, when combat damage assignments are complete, each creature that precedes 
that blocking creature in its order is assigned lethal damage. When checking for 
assigned lethal damage, take into account damage already marked on the creature and 
damage from other creatures that's being assigned during the same combat damage step, 
but not any abilities or effects that might change the amount of damage that's 
actually dealt. An amount of damage that's greater than a creature's lethal damage 
may be assigned to it.*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1bc")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()==0)
then
	System.out.println("510.1c -> Nessuna creatura sta bloccando "+$g.attackingCreatures.object.getNameAsString());
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else {
		$g.attackingCreatures.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1c 1block"
/*--- November 19, 2021 ---	*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1bc")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()==1)
then
	System.out.println("510.1c -> Una creatura sta bloccando "+$g.attackingCreatures.object.getNameAsString());
	$g.attackingCreatures.object.blockedBy.getObject(0).combatDamage += $g.attackingCreatures.object.damageToAssign;
	if($g.attackingCreatures.hasNext()){
		$g.attackingCreatures.next();
	} else {
		$g.attackingCreatures.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1c moreblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
no-loop true
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1bc")
	eval($g.attackingCreatures.index>-1)
	eval($g.attackingCreatures.object.blockedBy.getSize()>1)
	$p : Player($id : id) from $ac.object
then
	System.out.println("510.1c moreblock -> "+$g.attackingCreatures.object.getNameAsString()+" � bloccato da pi� creature");
	Permanent attacker = $g.attackingCreatures.object;
	if(attacker.damageAssignmentOrder.hasNext()){
		attacker.damageAssignmentOrder.next();
		Permanent blocker = attacker.damageAssignmentOrder.object;
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 51011;
		choice.choiceText = "Damage of "+attacker.getNameAsString()+" to assign to "+blocker.getNameAsString();
		
		int min = 0;
		int max = 0;
		int toughnessInt = Integer.parseInt(blocker.toughness[0]);
		int toughnessResidua = toughnessInt - blocker.combatDamage - blocker.markedDamage;
		if(toughnessResidua < attacker.damageToAssign){
			min = toughnessResidua;
			max = attacker.damageToAssign;
		} else {
			min = attacker.damageToAssign;
			max = attacker.damageToAssign;
		}
		while(min<=max){
			choice.addOption(Integer.toString(min),Integer.toString(min));
			min++;
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	} else if($g.attackingCreatures.hasNext()){
		attacker.damageAssignmentOrder.toHead();
		$g.attackingCreatures.next();
	} else {
		attacker.damageAssignmentOrder.toHead();
		$g.attackingCreatures.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1c answerHandler"
/*--- November 19, 2021 ---	*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 51011)
then
	System.out.println("510.1c answer --> Assegnamento danni ai bloccanti");
	Permanent blocker = $g.attackingCreatures.object.damageAssignmentOrder.object;
	int combatDamageInt = Integer.parseInt($ca.idOptions.get(0));	
	blocker.combatDamage += combatDamageInt;
	$g.attackingCreatures.object.damageToAssign = $g.attackingCreatures.object.damageToAssign - combatDamageInt;
	System.out.println(blocker.getNameAsString()+" riceve "+combatDamageInt+", nuovo totale: "+blocker.combatDamage);
	
	retract($ca);
	update($g);
end
	

rule "510.1d prepare"
/*
--- November 19, 2021 ---
510.1d. A blocking creature assigns combat damage to the creatures it's blocking. 
If it isn't currently blocking any creatures (if, for example, they were destroyed 
or removed from combat), it assigns no combat damage. If it's blocking exactly one 
creature, it assigns all its combat damage to that creature. If it's blocking two 
or more creatures, it assigns its combat damage to those creatures according to the 
damage assignment order announced for it. This may allow the blocking creature to 
divide its combat damage. However, it can't assign combat damage to a creature that 
it's blocking unless, when combat damage assignments are complete, each creature 
that precedes that blocked creature is assigned lethal damage. When checking for 
assigned lethal damage, take into account damage already marked on the creature and 
damage from other creatures that's being assigned during the same combat damage step, 
but not any abilities or effects that might change the amount of damage that's 
actually dealt. An amount of damage that's greater than a creature's lethal damage 
may be assigned to it.*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1d")
	eval($g.blockingCreatures.index == -1)
then
	System.out.println("510.1d prepare "+$g.defendingPlayers.index+" "+$g.defendingPlayers.getSize());
	$g.defendingPlayers.next();
	if($g.blockingCreatures.getSize()>0){
		$g.blockingCreatures.movePointer(0);
	} else {
		System.out.println("Non ci sono creature per bloccare");
		$g.defendingPlayers.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1d noblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1d")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()==0)
then
	System.out.println("510.1d -> "+$g.blockingCreatures.object.getNameAsString()+" non sta bloccando nessuno");
	if($g.blockingCreatures.hasNext()){
		System.out.println("510.1d noblock -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("510.1d noblock -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("510.1d noblock -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1d 1block"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1d")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()==1)
then
	System.out.println("510.1d -> "+$g.blockingCreatures.object.getNameAsString()+" sta bloccando una sola creatura");
	$g.blockingCreatures.object.blockedCreatures.getObject(0).combatDamage += $g.blockingCreatures.object.damageToAssign;
	if($g.blockingCreatures.hasNext()){
		System.out.println("510.1d 1block -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("510.1d 1block -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("510.1d 1block -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1d not right player"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
salience 100
when
	$g: Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1d")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()>1)
	eval($g.blockingCreatures.object.idController != $g.defendingPlayers.object.id);
then
	if($g.blockingCreatures.hasNext()){
		System.out.println("510.1d not rp -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("510.1d not rp -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("510.1d not rp -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1d moreblock"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
no-loop true
when 
	$g:Game(stage == Game.GAME_STAGE, $de : defendingPlayers, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.1d")
	eval($g.blockingCreatures.index>-1)
	eval($g.blockingCreatures.object.blockedCreatures.getSize()>1)
	eval($g.blockingCreatures.object.idController == $g.defendingPlayers.object.id);
	$p : Player($id : id) from $de.object
then
	System.out.println("510.1d -> "+$g.blockingCreatures.object.getNameAsString()+" sta bloccando pi� creature");
	Permanent blocker = $g.blockingCreatures.object;
	if(blocker.damageAssignmentOrder.hasNext()){
		blocker.damageAssignmentOrder.next();
		Permanent attacker = blocker.damageAssignmentOrder.object;
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 51012;
		choice.choiceText = "Damage of "+blocker.getNameAsString()+" to assign to "+attacker.getNameAsString();
		
		int min = 0;
		int max = 0;
		int toughnessInt = Integer.parseInt(attacker.toughness[0]);
		int toughnessResidua = toughnessInt - attacker.combatDamage - blocker.markedDamage;
		if(toughnessResidua < blocker.damageToAssign){
			min = toughnessResidua;
			max = blocker.damageToAssign;
		} else {
			min = blocker.damageToAssign;
			max = blocker.damageToAssign;
		}
		while(min<=max){
			choice.addOption(Integer.toString(min),Integer.toString(min));
			min++;
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
	} else if($g.blockingCreatures.hasNext()){
		System.out.println("510.1d moreblock -> Passo alla prossima creatura");
		$g.blockingCreatures.next();
	} else if($g.defendingPlayers.hasNext()){
		System.out.println("510.1d moreblock -> Passo al prossimo giocatore");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.next();
	} else {
		System.out.println("510.1d moreblock -> Passo al prossimo step");
		$g.blockingCreatures.toHead();
		$g.defendingPlayers.toHead();
		$g.stepCombatDamage.next();
	}
	update($g);
end


rule "510.1d answerHandler"
/*--- November 19, 2021 ---*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE)
	$ca: ChoiceAnswer(idChoice == 51012)
then
	System.out.println("510.1d answer --> Assegnamento danni agli attaccanti");
	Permanent attacker = $g.blockingCreatures.object.damageAssignmentOrder.object;
	int combatDamageInt = Integer.parseInt($ca.idOptions.get(0));	
	attacker.combatDamage += combatDamageInt;
	$g.blockingCreatures.object.damageToAssign = $g.blockingCreatures.object.damageToAssign - combatDamageInt;
	System.out.println(attacker.getNameAsString()+" riceve "+combatDamageInt+", nuovo totale: "+attacker.combatDamage);
	
	retract($ca);
	update($g);
end


rule "510.1e"
//Non gestita, gli passo soltanto danni legali
/*
--- November 19, 2021 ---
510.1e. Once a player has assigned combat damage from each attacking or blocking 
creature he or she controls, the total damage assignment (not solely the damage 
assignment of any individual attacking or blocking creature) is checked to see if 
it complies with the above rules. If it doesn't, the combat damage assignment is 
illegal; the game returns to the moment before that player began to assign combat 
damage. (See rule 717, "Handling Illegal Actions").*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE)
then
end


rule "510.2"
/*
November 19, 2021
510.2. Second, all combat damage that's been assigned is dealt simultaneously. 
This turn-based action doesn't use the stack. No player has the chance to cast 
spells or activate abilities between the time combat damage is assigned and the 
time it's dealt.*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.2")
then
	System.out.println("510.2 -> Assegnamento danni");
	for(Permanent creature : $g.battleField){
		creature.damageDealt += creature.combatDamage;
		creature.combatDamage = 0;
	}
	for(Player player : $g.priorityOrder){
		player.damageDealt += player.combatDamage;
		player.combatDamage = 0;
	}
	$g.stepCombatDamage.next();
	update($g);
end


rule "510.3"
/*
November 19, 2021
510.3. Third, the active player gets priority. (See rule 117, "Timing and Priority.")*/
agenda-group "general"
dialect "mvel"
salience 500
when
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage")
	eval($g.stepCombatDamage.getObject() == "510.3")
	$p : Player() from $ac.object
then
	$g.priorityMarker.movePointer($p);
	$g.stepTimeFrame = Game.DURING_TIME_FRAME;
	System.out.println("510.3 Priority player: " + $g.priorityMarker.getObject().nickname);
	GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
	update($g);
end

rule "510.3a"
	/* 
	November 19, 2021
	510.3a. Any abilities that triggered on damage being dealt or while state-based actions are performed afterward are put onto 
	the stack before the active player gets priority; the order in which they triggered doesn't matter. (See rule 603, "Handling Triggered Abilities.") */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "510.4 part 1a"
/*
Tommaso Romani Nicol� Posta
November 19, 2021
510.4. If at least one attacking or blocking creature has first strike (see rule 702.7) or double strike (see rule 702.4) as the combat damage step begins, the 
only creatures that assign combat damage in that step are those with first strike or double strike. After that step, instead of proceeding to the end of 
combat step, the phase gets a second combat damage step. The only creatures that assign combat damage in that step are the remaining attackers and blockers 
that had neither first strike nor double strike as the first combat damage step began, as well as the remaining attackers and blockers that currently have 
double strike. After that step, the phase proceeds to the end of combat step.*/
agenda-group "general"
dialect "mvel"
no-loop true
salience 500
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME, $atk: attackingCreatures, $blk: blockingCreatures)
	eval($g.currentStep.getObject().name == "combat damage" && $g.currentStep.getObject().additional == true)
	eval($g.stepCombatDamage.getObject() == "510.1a")
	eval($g.firstStrikeAttaking == false)
	$allCardsInCombact: (Permanent() from $atk.listReference or Permanent() from $blk.listReference)

	exists(Permanent(
		(checkKeywordAbility("Double strike") || checkKeywordAbility("First strike"))
	) from $allCardsInCombact)
	
then
	System.out.println("510.4 part 1a");
	//Mi salvo la lista di tutti gli attaccanti e difensori di prima
	System.out.println("Tutti gli attaccanti selezionati "+$atk.listReference);
	

	// copia della lista
	for(Permanent tmp: $atk.listReference) {
		$g.stepFirstStikeAttackingCreatures.add(tmp);
	}

	// ricerca carte first/double strike
	$atk.listReference.clear();
	for(Permanent tmp: $g.stepFirstStikeAttackingCreatures) {
		if (tmp.checkKeywordAbility("First strike") || tmp.checkKeywordAbility("Double strike")){
			System.out.println("Trovato FIRST/DOUBLE STRIKE da riaggiungere alla lista degli attaccanti");
			$atk.listReference.add(tmp);
		}
	}
	
	System.out.println("Tutti gli attaccanti selezionati dopo averli salvati " + $g.stepFirstStikeAttackingCreatures);
	System.out.println("Tutti gli attaccanti selezionati con First Strike" + $atk.listReference);

	$g.firstStrikeAttaking = true;
	update($g)

end



rule "510.4 part 2a"
/*
Tommaso Romani Nicol� Posta
November 19, 2021
510.4. If at least one attacking or blocking creature has first strike (see rule 702.7) or double strike (see rule 702.4) as the combat damage step begins, the 
only creatures that assign combat damage in that step are those with first strike or double strike. After that step, instead of proceeding to the end of 
combat step, the phase gets a second combat damage step. The only creatures that assign combat damage in that step are the remaining attackers and blockers 
that had neither first strike nor double strike as the first combat damage step began, as well as the remaining attackers and blockers that currently have 
double strike. After that step, the phase proceeds to the end of combat step.*/
agenda-group "general"
dialect "mvel"
no-loop true
salience 500
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME, $atk: attackingCreatures)
	eval($g.currentStep.getObject().name == "combat damage" && $g.currentStep.getObject().additional == false)
	eval($g.stepCombatDamage.getObject() == "510.1a")
	eval($g.firstStrikeAttaking == true)
	eval($g.notRedoDamage == false)
then
	System.out.println("510.4 part 2a");


	for(Permanent tmp: $atk.listReference) {
		$g.auxiliaryListFirstStrike.add(tmp);
	
	}
	$atk.listReference.clear();

	// double strike
	for(Permanent tmp: $g.auxiliaryListFirstStrike) {
		if (tmp.checkKeywordAbility("Double strike")){
			$atk.listReference.add(tmp);
		}
	}
	
	for(Permanent tmp: $g.stepFirstStikeAttackingCreatures) {
		if (!tmp.checkKeywordAbility("First strike") && !tmp.checkKeywordAbility("Double strike")){
			$atk.listReference.add(tmp);
		}
	}

	$g.stepFirstStikeAttackingCreatures.clear();

	for(Permanent tmp: $g.auxiliaryListFirstStrike) {
		if (!tmp.checkKeywordAbility("Double strike")){
			$g.stepFirstStikeAttackingCreatures.add(tmp);
		}
	}
	$g.auxiliaryListFirstStrike.clear();
	$g.firstStrikeAttaking = false;
	update($g);

end

rule "510.4 part 3a"
/*
Tommaso Romani Nicol� Posta
November 19, 2021
510.4. If at least one attacking or blocking creature has first strike (see rule 702.7) or double strike (see rule 702.4) as the combat damage step begins, the 
only creatures that assign combat damage in that step are those with first strike or double strike. After that step, instead of proceeding to the end of 
combat step, the phase gets a second combat damage step. The only creatures that assign combat damage in that step are the remaining attackers and blockers 
that had neither first strike nor double strike as the first combat damage step began, as well as the remaining attackers and blockers that currently have 
double strike. After that step, the phase proceeds to the end of combat step.*/
agenda-group "general"
dialect "mvel"
no-loop true
salience 400
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.DURING_TIME_FRAME)
	eval($g.currentStep.getObject().name == "combat damage" && $g.currentStep.getObject().additional == true)
	eval($g.stepCombatDamage.getObject() == "510.3")
	eval($g.firstStrikeAttaking == true)
	eval($g.notRedoDamage == true)
then

	$g.attackingPlayer.toHead();
	$g.defendingPlayers.toHead();
	
	$g.attackingCreatures.toHead();
	
	$g.blockingCreatures.toHead();

	$g.stepCombatDamage.movePointer(0);
	$g.currentStep.next();

	$g.stepTimeFrame = Game.BEGIN_TIME_FRAME;
	System.out.println("510.4 part 3a");

	$g.notRedoDamage = false;
	update($g)

end



rule "510.4 update_damage"
/*
Tommaso Romani Nicol� Posta
November 19, 2021
510.4. If at least one attacking or blocking creature has first strike (see rule 702.7) or double strike (see rule 702.4) as the combat damage step begins, the 
only creatures that assign combat damage in that step are those with first strike or double strike. After that step, instead of proceeding to the end of 
combat step, the phase gets a second combat damage step. The only creatures that assign combat damage in that step are the remaining attackers and blockers 
that had neither first strike nor double strike as the first combat damage step began, as well as the remaining attackers and blockers that currently have 
double strike. After that step, the phase proceeds to the end of combat step.*/
agenda-group "general"
dialect "mvel"
no-loop true
salience 500
when
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME, $bf: battleField)
	eval($g.currentStep.getObject().name == "combat damage" && $g.currentStep.getObject().additional == false)
	eval($g.updateDamage == true)

	$pmt: Permanent(
				cardType[0].contains("creature"),
				Integer.parseInt(toughness[0]) > 0,
				Integer.parseInt(toughness[0]) <= markedDamage
			) from $bf
then
	
	System.out.println("510.4 --> Controlling if there are creatures that have marked damage greater or equal than toughness.");
	System.out.println($pmt.getNameAsString+" ha toughness "+Integer.parseInt($pmt.toughness[0])+" e danni "+$pmt.markedDamage);
	System.out.println($pmt.getNameAsString+" viene distrutta");
	$g.destroy($pmt);
	System.out.println("----------- TEST 510.4 -----------");
	$g.updateDamage = false;
	update($g)
end

//END OF COMBAT STEP

rule "511.1"
	/* 
	November 19, 2021
	511.1 The end of combat step has no turn-based actions. Once it begins, the active player gets priority. (See rule 117, "Timing and Priority.")*/
	agenda-group "general"
	dialect "mvel"
	salience 50
	when
		$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
		eval($g.currentStep.getObject().name == "end of combat")
		$p : Player() from $ac.object
	then
		$g.priorityMarker.movePointer($p);
		$g.stepTimeFrame = Game.DURING_TIME_FRAME;
		System.out.println("511.1 Priority player: " + $g.priorityMarker.getObject().nickname);
		GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
		update($g);
end

rule "511.2"
	/*
	November 19, 2021
	511.2. Abilities that trigger "at end of combat" trigger as the end of combat step begins. Effects that last "until end of combat" expire at the end of the combat phase. */
	agenda-group "general"
	dialect "mvel"
	salience 50
	when
	then
end

rule "511.3"
/*
November 19, 2021
511.3. As soon as the end of combat step ends, all creatures and planeswalkers 
are removed from combat. After the end of combat step ends, the combat phase is over 
and the postcombat main phase begins (see rule 505).*/
agenda-group "general"
dialect "mvel"
salience 10
no-loop true
when
	$g:Game(stage == Game.GAME_STAGE, $ac : attackingPlayer, phaseTimeFrame == Game.END_TIME_FRAME, stepTimeFrame == Game.END_TIME_FRAME)
	eval($g.currentStep.getObject().name == "end of combat")
	eval($ac.index!=-1)
then
	System.out.println("511.3 --> Resetto il combat");
	for(Permanent creature : $g.battleField){
		creature.removedFromCombat = true;
	}
	
	$g.attackingPlayer.toHead();
	$g.defendingPlayers.toHead();
	$g.defendingPlayers.listReference.clear();
	$g.possibleTarget.clear();
	
	$g.attackingCreatures.toHead();
	$g.attackingCreatures.listReference.clear();
	
	$g.blockingCreatures.toHead();
	$g.blockingCreatures.listReference.clear()
	
	$g.stepDeclareAttackers.movePointer(0);
	$g.stepDeclareBlockers.movePointer(0);
	$g.stepCombatDamage.movePointer(0);

	$g.auxiliaryListFirstStrike.clear();
	$g.stepFirstStikeAttackingCreatures.clear();
	$g.notRedoDamage = true;
	
	for(Step step : $g.currentStep.listReference){
		if(step.name == "declare blockers" || step.name == "combat damage"){
			step.toSkip = false;
		}
	}
	update($g);
end


//ENDING PHASE
rule "512.1"
/*November 19, 2021*/
//The ending phase consists of two steps: end and cleanup.
dialect "mvel"
agenda-group "initialization"
no-loop true
	when		
		$p: Player() 
		$ph : Phase(this.isEmpty(), name == "ending") from $p.turn
	then
		$ph.add(new Step("end",false));			
		$ph.add(new Step("cleanup",false));			
		System.out.println("Rule 512.1 --> Player:  "+$p.getNickname());
		System.out.println("Step's number of ENDING PHASE  : " + $ph.size());
		update($p);
end

// END STEP

rule "513.1"
/* 
November 19, 2021
The end step has no turn-based actions. Once it begins, the active player gets priority. (See rule 117, "Timing and Priority.") */
agenda-group "general"
salience 200
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="end")
	$p : Player() from $ac.object
then
	System.out.println("513.1");
end

rule "513.1a"
/*
November 19, 2021
Previously, abilities that trigger at the beginning of the end step 
were printed with the trigger condition �at end of turn.� Cards that 
were printed with that text have received errata in the Oracle card 
reference to say �at the beginning of the end step� or �at the beginning 
of the next end step.�*/
agenda-group "general"
salience 100
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="end")
	$p : Player() from $ac.object
then
	System.out.println("513.1a");
end

rule "513.2"
/*
November 19, 2021
	ELIMINATO DA YAWGATOG
	DA RIVEDERE
Second, the active player gets priority. Players may cast spells and 
activate abilities.*/
agenda-group "general"
salience 50
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="end")
	$p : Player() from $ac.object
then
	$g.stepTimeFrame = Game.DURING_TIME_FRAME;
	$g.phaseTimeFrame = Game.DURING_TIME_FRAME;
	$g.priorityMarker.movePointer($p);
	System.out.println("513.2 Priority player: " + $g.priorityMarker.getObject().nickname);
	GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $p.nickname);
	update($g);
end

rule "513.3"
/*
November 19, 2021
	513.2 NUOVO NUMERO
If a permanent with an ability that triggers �at the beginning of the 
end step� enters the battlefield during this step, that ability won�t trigger 
until the next turn�s end step. Likewise, if a delayed triggered ability that 
triggers �at the beginning of the next end step� is created during this step, 
that ability won�t trigger until the next turn�s end step. In other words, the 
step doesn�t �back up� so those abilities can go on the stack. This rule 
applies only to triggered abilities; it doesn�t apply to continuous effects 
whose durations say �until end of turn� or �this turn.� 
(See rule 514, �Cleanup Step.�)*/
/*NEW ora � 513.2*/
agenda-group "general"
dialect "mvel"
when 
then
end


//CLEANUP STEP 

rule "514.1"
/*
November 22, 2022
First, if the active players hand contains more cards than his or her 
maximum hand size (normally seven), he or she discards enough cards to reduce 
his or her hand size to that number. This turn-based action doesnt use the 
stack.

Edited by Nicol� Posta, Tommaso Romani, Nicol� Vescera, Fabrizio Fagiolo, Cristian Cosci.
*/
agenda-group "general"
salience 300
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $players : players, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="cleanup")

	$p : Player(hand.size > maxHandSize) from $players
then
	//passa alla fase di scarto delle carte in eccesso
	$p.discardToMaxHandSize = true;
	$g.stepTimeFrame = Game.CLEANUP_TIME_FRAME;
	System.out.println("514.1 -> discrdToMaxHandSize started");
	update($g);
end

rule "514.1 selectHandler"
/*
November 22, 2022
First, if the active players hand contains more cards than his or her 
maximum hand size (normally seven), he or she discards enough cards to reduce 
his or her hand size to that number. This turn-based action doesnt use the 
stack.

Edited by Nicol� Posta, Tommaso Romani, Nicol� Vescera, Fabrizio Fagiolo, Cristian Cosci.
*/
agenda-group "general"
salience 200
dialect "mvel"
when
	$g : Game(stage == Game.GAME_STAGE, $players : players, stepTimeFrame == Game.CLEANUP_TIME_FRAME)
	$p : Player(discardToMaxHandSize && beginningDiscardingToMaxHandSize) from $players
then
	//crea la MakeChoise da inviare al Node
	MakeChoice choice = new MakeChoice();
	choice.idChoice = Game.DISCARD_TO_MAXHANDSIZE;
	choice.choiceText = "Choose " + ($p.getHand().size() - $p.getMaxHandSize()) + " card/s to discard";
	for(Card card : $p.hand) {
		choice.addOption(card.magicTargetId, card.getNameAsString());
	}
	
	//invia la choice al server 
	GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $p.id);
	
	//Impedisce che questa regola venga avviata molteplici volte mentre il giocatore aspetta di fare la scelta
	$p.beginningDiscardingToMaxHandSize = false;
	update($g);
end

rule "514.1 answerHandler"
/*
November 22, 2022
First, if the active players hand contains more cards than his or her 
maximum hand size (normally seven), he or she discards enough cards to reduce 
his or her hand size to that number. This turn-based action doesnt use the 
stack.

Edited by Nicol� Posta, Tommaso Romani, Nicol� Vescera, Fabrizio Fagiolo, Cristian Cosci.
*/
agenda-group "general"
salience 100
dialect "mvel"
when
	$g : Game(stage == Game.GAME_STAGE, $players : players, stepTimeFrame == Game.CLEANUP_TIME_FRAME)
	$p : Player(discardToMaxHandSize && !beginningDiscardingToMaxHandSize) from $players
	$ca: ChoiceAnswer(idChoice == Game.DISCARD_TO_MAXHANDSIZE, idPlayer == $p.id)
then

	//elimina le carte solo se � stato scelto il numero corretto di carte
	if ($ca.getIdOptions().size() == ($p.getHand().size() - $p.getMaxHandSize())) {
		for(String cardId : $ca.getIdOptions()) {
	    	$p.hand.remove(cardId);
	    }
	} else {
		//avvisa il player della scelta errata della carte da scartare
		System.out.println("514.1 -> Il giocatore ha scelto un numero errato di carte !!");
		GameEngine.sendToNode("Il giocatore " + $p.nickname + " ha scelto un numero errato di carte !!");
	}
	
	//reset delle varibili allo stato iniziale per passare alle fasi successive del gioco
	$p.discardToMaxHandSize = false;
	$p.beginningDiscardingToMaxHandSize = true;
	$g.stepTimeFrame = Game.BEGIN_TIME_FRAME;
	retract($ca);
	update($p);
	update($g);
end

rule "514.2"
/*
November 19, 2021
Second, the following actions happen simultaneously: all damage marked on 
permanents (including phased-out permanents) is removed and all 
�until end of turn� and �this turn� effects end. 
This turn-based action doesn�t use the stack.*/
agenda-group "general"
salience 100
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="cleanup")	
then
	for(Permanent permanent : $g.battleField){
		permanent.markedDamage = 0;
	}
	System.out.println("514.2 cleanup");
end

rule "514.3"
/*
November 19, 2021
Normally, no player receives priority during the cleanup step, so no spells 
can be cast and no abilities can be activated. However, this rule is subject 
to the following exception:*/
agenda-group "general"
salience 50
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $ac : activePlayer, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="cleanup")
	//$p : Player() from $ac.object
then
	System.out.println("514.3 cleanup");
end

rule "514.3a case 1"
/*
November 19, 2021
At this point, the game checks to see if any state-based actions would be 
performed and/or any triggered abilities are waiting to be put onto the 
stack (including those that trigger �at the beginning of the next cleanup step�). 
If so, those state-based actions are performed, then those triggered abilities 
are put on the stack, then the active player gets priority. Players may cast spells 
and activate abilities. Once the stack is empty and all players pass in succession, 
another cleanup step begins.*/
//no-loop true
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="cleanup")
	forall (Player(triggeredAbilities.isEmpty()))
then
	$g.stepTimeFrame = Game.END_TIME_FRAME;
	$g.phaseTimeFrame = Game.END_TIME_FRAME;
	$g.turnTimeFrame = Game.END_TIME_FRAME;
	$g.activePlayer.getObject().playedLands=0; //land giocate si azzerano
	System.out.println("514.3a case1");
	update($g);
end

rule "514.3a case 2"
/*
November 19, 2021
At this point, the game checks to see if any state-based actions would be 
performed and/or any triggered abilities are waiting to be put onto the 
stack (including those that trigger �at the beginning of the next cleanup step�). 
If so, those state-based actions are performed, then those triggered abilities 
are put on the stack, then the active player gets priority. Players may cast spells 
and activate abilities. Once the stack is empty and all players pass in succession, 
another cleanup step begins.*/
agenda-group "general"
dialect "mvel"
when 
	$g:Game(stage == Game.GAME_STAGE, $cs : currentStep,  stepTimeFrame == Game.BEGIN_TIME_FRAME)
	eval($g.currentStep.getObject().name=="cleanup")
	Player(!triggeredAbilities.isEmpty())
then
	//verranno attivate le abiliti�	
	$cs.addObject(new Step("cleanup",true));
	System.out.println("514.3a case2");
	$g.priorityMarker.movePointer($g.activePlayer.getObject());
	System.out.println("Priority player: " + $g.priorityMarker.getObject().nickname);
	GameEngine.sendToNode("- Priority Player: " + $g.priorityMarker.getObject().nickname + " - Active Player: "+ $g.activePlayer.getObject().nickname);	
	update($g);
end

// Casting Spells
rule "601.2a instant"
/* 
November 19, 2021
601.2a
To propose the casting of a spell, a player first moves that card (or that copy of a card) from where it is to the stack. It becomes the topmost 
object on the stack. It has all the characteristics of the card (or the copy of a card) associated with it, and that player becomes its controller. 
The spell remains on the stack until it's countered, it resolves, or an effect moves it elsewhere.
*/

agenda-group "general"
dialect "mvel"
when 
	Game(stage == Game.GAME_STAGE, castingSpell == null)
	$act: Action($id: id, option == Game.CAST_INSTANT_SPELL)
	$p: Player(id == $id)
then
	MakeChoice choice = new MakeChoice();
	choice.idChoice = 60121;
	choice.choiceText = "Choose which card to play";
	boolean found = false;
	// La ricerca delle carte castabili va fatta in tutte le zone
	for(Card card : $p.hand) {
		if(card.cardType.size() > 0 && card.cardType[0].contains("instant")
		&& !card.cardType[0].contains("land")) {
			choice.addOption(card.magicTargetId, card.getNameAsString());
			found = true;
		}
	}
	if(found) {
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " wants cast a spell.");
		System.out.println("The player " + $p.nickname + " wants cast a spell.");
	} else {
		GameEngine.sendToNode("You have not instant spells to cast.");
		System.out.println("601.2a -> The player " + $p.nickname + "  has not instant spells to cast.");
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
	}
end


rule "601.2a noninstant"
/* 
November 19, 2021
601.2a
To propose the casting of a spell, a player first moves that card (or that copy of a card) from where it is to the stack. It becomes the topmost 
object on the stack. It has all the characteristics of the card (or the copy of a card) associated with it, and that player becomes its controller. 
The spell remains on the stack until it's countered, it resolves, or an effect moves it elsewhere. 
*/
agenda-group "general"
dialect "mvel"
when 
	Game(stage == Game.GAME_STAGE, castingSpell == null)
	$act: Action($id: id, option == Game.CAST_NON_INSTANT_SPELL)
	$p: Player(id == $id)
then
	MakeChoice choice = new MakeChoice();
	choice.idChoice = 60121;
	choice.choiceText = "Choose which card to play";
	// La ricerca delle carte castabili va fatta in tutte le zone
	boolean found = false;
	for(Card card : $p.hand) {
		if(card.cardType.size() > 0 && !card.cardType[0].contains("instant")
			&& !card.cardType[0].contains("land")) {
			choice.addOption(card.magicTargetId, card.getNameAsString());
			found = true;
		}
	}
	if(found) {
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " wants cast a spell.");
		System.out.println("The player " + $p.nickname + " wants cast a spell.");
	} else {
		GameEngine.sendToNode("You have not non-instant spells to cast.");
		System.out.println("601.2a -> The player " + $p.nickname + "  has not non-instant spells to cast.");
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
	}
end


rule "601.2a answerHandler"
/*
November 19, 2021
601.2a 
To propose the casting of a spell, a player first moves that card (or that copy of a card) from where it is to the stack. It becomes the topmost 
object on the stack. It has all the characteristics of the card (or the copy of a card) associated with it, and that player becomes its controller. 
The spell remains on the stack until it's countered, it resolves, or an effect moves it elsewhere.
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE)
	$act: Action($id: id,$option:option, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
	$p: Player(id == $id)
	$ca: ChoiceAnswer(idChoice == 60121, idPlayer == $id)	
then
	for(Card card : $p.hand) {
		if(card.magicTargetId == $ca.idOptions.get(0)){
			Spell s = new Spell(card, $g.giveMeMyId(), $id, $g.getIdStackCounter());
			if($option==2){
				System.out.println("instant spell true");
				s.setInstantSpell(true);
			}else{
				System.out.println("instant spell false");
				s.setInstantSpell(false);
			}
			s.setIdPlayer($id);
			$g.castingSpell = s;
		}
	}
	$p.hand.remove($g.castingSpell.originCard);
	GameEngine.sendToNode("The player " + $p.nickname + " choosen to cast " + $g.castingSpell.name);
	System.out.println("601.2a -> The player " + $p.nickname + " choosen to cast " + $g.castingSpell.name);
	retract($ca);
	update($g);
end


rule "601.2b"
/* 
601.2b. 
November 19, 2021
If the spell is modal, the player announces the mode choice (see rule 700.2). If the player wishes to splice any cards onto the spell (see rule 702.47), they reveal those cards in their hand. 
If the spell has alternative or additional costs that will be paid as it's being cast such as buyback or kicker costs (see rules 118.8 and 118.9), the player announces their intentions to pay 
any or all of those costs (see rule 601.2f). A player can't apply two alternative methods of casting or two alternative costs to a single spell. If the spell has a variable cost that will be 
paid as it's being cast (such as an {X} in its mana cost; see rule 107.3), the player announces the value of that variable. If the value of that variable is defined in the text of the spell by a 
choice that player would make later in the announcement or resolution of the spell, that player makes that choice at this time instead of that later time. If a cost that will be paid as the spell 
is being cast includes hybrid mana symbols, the player announces the nonhybrid equivalent cost they intend to pay. If a cost that will be paid as the spell is being cast includes Phyrexian mana 
symbols, the player announces whether they intend to pay 2 life or the corresponding colored mana cost for each of those symbols. Previously made choices (such as choosing to cast a spell with 
flashback from a graveyard or choosing to cast a creature with morph face down) may restrict the player's options when making these choices.
*/
	agenda-group "general"
	dialect "mvel"
	when 
		Game(stage == Game.GAME_STAGE)
	then
		// Da implementare con le carte
end



rule "601.2c fasi"
//martina-damiano 
//definizione delle fasi che devono essere susseguite a seconda se la spell è un aura o meno (target)


/* 
601.2c 

November 19, 2021
 The player announces their choice of an appropriate object or player for each target the spell requires. A spell may require some targets 
 only if an alternative or additional cost (such as a kicker cost) or a particular mode was chosen for it; otherwise, the spell is cast as 
 though it did not require those targets. Similarly, a spell may require alternative targets only if an alternative or additional cost was 
 chosen for it. If the spell has a variable number of targets, the player announces how many targets they will choose before they announce 
 those targets. In some cases, the number of targets will be defined by the spell's text. Once the number of targets the spell has is 
 determined, that number doesn't change, even if the information used to determine the number of targets does. The same target can't be 
 chosen multiple times for any one instance of the word "target" on the spell. However, if the spell uses the word "target" in multiple 
 places, the same object or player can be chosen once for each instance of the word "target" (as long as it fits the targeting criteria). 
 If any effects say that an object or player must be chosen as a target, the player chooses targets so that they obey the maximum possible 
 number of such effects without violating any rules or effects that say that an object or player can't be chosen as a target. The chosen 
 objects and/or players each become a target of that spell. (Any abilities that trigger when those objects and/or players become the target 
 of a spell trigger at this point; they'll wait to be put on the stack until the spell has finished being cast.)
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getCastingSpell()!=null)
	$spell: Spell(targetted_id==-1, $id: idPlayer, $scs: stepCastingSpell.listReference) from $g.getCastingSpell()	
	eval($scs.size()==0)
	$p: Player(id == $id)
	$listaSottoTipi: LinkedList() from $spell.getSubtype()
	$sottoTipo : String() from $listaSottoTipi
then
	if($sottoTipo == "Aura"){
		System.out.println("AURA");
		$scs.add("601.2cfase1");
		$scs.add("601.2cfase2");	
	}
	////da aggiungere 
	//$sda.add("601.2d");
	//$sda.add("601.2e");
	$scs.add("601.2f");
	$scs.add("601.2g");
	$scs.add("601.2h");
	
	$spell.stepCastingSpell.next();
	update($g);			
end


rule "601.2cfase1"
//martina-damiano proposta al giocatore delle carte che possono essere possibili target dell'aura giocata, prese da tutte le zone di gioco 
// il messaggio che viene inviato è composto da
//numero che rappresenta la zona+header+idcartatarget questo perchè ci permette di tenere traccia della zona da cui è stato selezionato il target		
//Pietro: inserito or per controllo Tipo e sottotipo
/* 
601.2c 
The player announces his or her choice of an appropriate player, object, or zone for each target the spell requires. A spell may require some targets 
only if an alternative or additional cost (such as a buyback or kicker cost), or a particular mode, was chosen for it; otherwise, the spell is cast as though 
it did not require those targets. If the spell has a variable number of targets, the player announces how many targets he or she will choose before he or 
she announces those targets. In some cases, the number of targets will be defined by the spell's text. Once the number of targets the spell has is determined, 
that number doesn't change, even if the information used to determine the number of targets does. The same target can't be chosen multiple times for any 
one instance of the word "target" on the spell. However, if the spell uses the word "target" in multiple places, the same object, player, or zone can be 
chosen once for each instance of the word "target" (as long as it fits the targeting criteria). If any effects say that an object or player must be chosen 
as a target, the player chooses targets so that he or she obeys the maximum possible number of such effects without violating any rules or effects that say 
that an object or player can't be chosen as a target. The chosen players, objects, and/or zones each become a target of that spell. (Any abilities that trigger 
when those players, objects, and/or zones become the target of a spell trigger at this point; they'll wait to be put on the stack until the spell 
has finished being cast.)
*/
/*
November 19, 2021
 The player announces their choice of an appropriate object or player for each target the spell requires. A spell may require some targets 
 only if an alternative or additional cost (such as a kicker cost) or a particular mode was chosen for it; otherwise, the spell is cast as 
 though it did not require those targets. Similarly, a spell may require alternative targets only if an alternative or additional cost was 
 chosen for it. If the spell has a variable number of targets, the player announces how many targets they will choose before they announce 
 those targets. In some cases, the number of targets will be defined by the spell's text. Once the number of targets the spell has is 
 determined, that number doesn't change, even if the information used to determine the number of targets does. The same target can't be 
 chosen multiple times for any one instance of the word "target" on the spell. However, if the spell uses the word "target" in multiple 
 places, the same object or player can be chosen once for each instance of the word "target" (as long as it fits the targeting criteria). 
 If any effects say that an object or player must be chosen as a target, the player chooses targets so that they obey the maximum possible 
 number of such effects without violating any rules or effects that say that an object or player can't be chosen as a target. The chosen 
 objects and/or players each become a target of that spell. (Any abilities that trigger when those objects and/or players become the target 
 of a spell trigger at this point; they'll wait to be put on the stack until the spell has finished being cast.)
*/
agenda-group "general"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getCastingSpell()!=null)
	$spell: Spell(targetted_id==-1, $id: idPlayer, $scs: stepCastingSpell.listReference) from $g.getCastingSpell()	
	$p: Player(id == $id)
	eval($spell.getStepCastingSpell().getObject().equals("601.2cfase1"))
then
	System.out.println("601.2c: si deve selezionare il target dell'aura");
	String tipoTarget="";
	int debug=1;
	LinkedList<Ability> la = $spell.getAbilities().get(0);
	for(Ability a : la){ 
		if(a.getTargetType()!=null && a.getTargetType().size()>0 && a.getTargetType().get(0)!=null){
			tipoTarget=a.getTargetType().get(0);
		}
	}		
		
	if(tipoTarget!=null){
		MakeChoice nchoice = new MakeChoice();
		nchoice.setIdChoice(601201);
		nchoice.setChoiceText("Choose target for Aura: "+$spell.getName().get(0));
		System.out.println("Choose target for "+$spell.getName().get(0)+" Target type: "+tipoTarget);
		String header="09890";	
		for(MagicObject nmo : $g.getBattleField()){
			System.out.println("Elemento confronto:  " + nmo.getSubtype().get(0).get(0));
			System.out.println("Tipo Target Trovato: " + tipoTarget);  //torna ad esempio land invece che island
			if(	nmo.getSubtype().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase()) ||
				nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){ 
				int idInviato=Integer.parseInt(""+1+header+nmo.getMagicTargetId());
				nchoice.addOption(idInviato, nmo.getName().get(0));
			}
		}

		for (MagicObject nmo : $g.getExile()) {
			if(nmo.getSubtype().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase()) ||
				nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
				int idInviato=Integer.parseInt(""+2+header+nmo.getMagicTargetId());
				nchoice.addOption(idInviato, nmo.getName().get(0));
			}
		}

		for (MagicObject nmo : $g.getStack()) {
			if(nmo.getSubtype().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase()) ||
				nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
				int idInviato=Integer.parseInt(""+3+header+nmo.getMagicTargetId());
				nchoice.addOption(idInviato, nmo.getName().get(0));
			}
		}	
		
		for (MagicObject nmo : $g.getCommand()) {
			if(nmo.getSubtype().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
				int idInviato=Integer.parseInt(""+4+header+nmo.getMagicTargetId());
				nchoice.addOption(idInviato, nmo.getName().get(0));
			}
		}	

		for (MagicObject nmo : $g.getAnte()) {
			if(nmo.getSubtype().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase()) ||
				nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
				int idInviato=Integer.parseInt(""+5+header+nmo.getMagicTargetId());
				nchoice.addOption(idInviato, nmo.getName().get(0));
			}
		}
		if (nchoice.getChoiceOptions().size() > 0) {
			System.out.println("Target papabili : " + nchoice.getChoiceOptions().size());
			GameEngine.sendToNode(nchoice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		}else{		
			System.out.println("Errore 601.2c tipo 2");
		}				
	}else{
		System.out.println("Errore 601.2c tipo 1");
	}	
	$spell.getStepCastingSpell().next();
	update($g);
end


rule "601.2cfase2"
//martina-damiano aggiunta del target alla carta dopo che è stata scelta dal giocatore
//l'id della zona mi permette di evitare di ricontrollare tutte le carte di tutte le zone!
/*
601.2c 
The player announces his or her choice of an appropriate player, object, or zone for each target the spell requires. A spell may require some targets 
only if an alternative or additional cost (such as a buyback or kicker cost), or a particular mode, was chosen for it; otherwise, the spell is cast as though 
it did not require those targets. If the spell has a variable number of targets, the player announces how many targets he or she will choose before he or 
she announces those targets. In some cases, the number of targets will be defined by the spell's text. Once the number of targets the spell has is determined, 
that number doesn't change, even if the information used to determine the number of targets does. The same target can't be chosen multiple times for any 
one instance of the word "target" on the spell. However, if the spell uses the word "target" in multiple places, the same object, player, or zone can be 
chosen once for each instance of the word "target" (as long as it fits the targeting criteria). If any effects say that an object or player must be chosen 
as a target, the player chooses targets so that he or she obeys the maximum possible number of such effects without violating any rules or effects that say 
that an object or player can't be chosen as a target. The chosen players, objects, and/or zones each become a target of that spell. (Any abilities that trigger 
when those players, objects, and/or zones become the target of a spell trigger at this point; they'll wait to be put on the stack until the spell 
has finished being cast.)
*/
/*
November 19, 2021
 The player announces their choice of an appropriate object or player for each target the spell requires. A spell may require some targets 
 only if an alternative or additional cost (such as a kicker cost) or a particular mode was chosen for it; otherwise, the spell is cast as 
 though it did not require those targets. Similarly, a spell may require alternative targets only if an alternative or additional cost was 
 chosen for it. If the spell has a variable number of targets, the player announces how many targets they will choose before they announce 
 those targets. In some cases, the number of targets will be defined by the spell's text. Once the number of targets the spell has is 
 determined, that number doesn't change, even if the information used to determine the number of targets does. The same target can't be 
 chosen multiple times for any one instance of the word "target" on the spell. However, if the spell uses the word "target" in multiple 
 places, the same object or player can be chosen once for each instance of the word "target" (as long as it fits the targeting criteria). 
 If any effects say that an object or player must be chosen as a target, the player chooses targets so that they obey the maximum possible 
 number of such effects without violating any rules or effects that say that an object or player can't be chosen as a target. The chosen 
 objects and/or players each become a target of that spell. (Any abilities that trigger when those objects and/or players become the target 
 of a spell trigger at this point; they'll wait to be put on the stack until the spell has finished being cast.)
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getCastingSpell()!=null)
	$ca: ChoiceAnswer(idChoice == 601201, $op : idOptions, $op!=null)
	$spell: Spell(targetted_id==-1, $id: idPlayer) from $g.getCastingSpell()
	$p: Player(id == $id)
	eval($spell.getStepCastingSpell().getObject().equals("601.2cfase2"))
then
	System.out.println("601.2c fase 2: aggiunta del target alla carta");
	String header="09890";	
	String[] selezioneUtente = ($op.get(0)+"").split(header);
	int zona		=	Integer.parseInt(selezioneUtente[0]);
	int idCartaTo	=	Integer.parseInt(selezioneUtente[1]);
	MagicObject cto	= 	null;
	int trovato		= 0;
	if(zona==1){
		for (MagicObject mo : $g.getBattleField()) {
			if(mo.magicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==2){
		for (MagicObject mo : $g.getExile()) {
			if(mo.magicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==3){
		for (MagicObject mo : $g.getStack()) {
			if(mo.magicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==4){
		for (MagicObject mo : $g.getCommand()) {
			if(mo.magicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==5){ 
		for (MagicObject mo : $g.getAnte()) {
			if(mo.magicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}		
	if(trovato==1){
		System.out.println("601.2c fase 2: id Target " + idCartaTo + " oggetto "+ cto.magicTargetId);
		$spell.targetted_id=idCartaTo;
		$spell.target=cto;
		System.out.println("601.2c fase 2: idSpell target" + $spell.targetted_id);	
		GameEngine.sendToNode("601.2c fase 2: The player " + $p.getNickname() + " has selected the target !");
		$spell.getStepCastingSpell().next();	
	}
	if(trovato==0){
		System.out.println("601.2c fase 2: Errore: target non aggiunto, carta non trovata!");	
	}		
	retract($ca)	
	update($g);
end



rule "601.2d"
/* 
November 19, 2021
601.2d
If the spell requires the player to divide or distribute an effect (such as damage or counters) 
among one or more targets, the player announces the division.
Each of these targets must receive at least one of whatever is being divided. 
*/
	agenda-group "general"
	dialect "mvel"
	when 
		Game(stage == Game.GAME_STAGE)
	then
		// Da implementare con le carte
end

rule "601.2e"
	/* 
	November 19, 2021
	601.2e. The game checks to see if the proposed spell can legally be cast. If the proposed spell is illegal, the game returns to the moment before the 
	casting of that spell was proposed (see rule 726, "Handling Illegal Actions").*/
	agenda-group "general"
	dialect "mvel"
	when 
		Game(stage == Game.GAME_STAGE)
	then
		// Da implementare con le carte
end

rule "601.2f"
	/* 
	November 19, 2021
	The player determines the total cost of the spell. Usually this is just the mana cost. Some spells have additional or alternative costs. Some effects may increase
	or reduce the cost to pay, or may provide other alternative costs. Costs may include paying mana, tapping permanents, sacrificing permanents, discarding cards, and so on.
	The total cost is the mana cost or alternative cost (as determined in rule 601.2b), plus all additional costs and cost increases, and minus all cost reductions. If multiple
	cost reductions apply, the player may apply them in any order. If the mana component of the total cost is reduced to nothing by cost reduction effects, it is considered to
	be {0}. It can't be reduced to less than {0}. Once the total cost is determined, any effects that directly affect the total cost are applied. Then the resulting total cost
	becomes "locked in." If effects would change the total cost after this time, they have no effect. */
	agenda-group "general"
	when 
		$g: Game(stage == Game.GAME_STAGE, castingSpell != null, castingSpell.getTotalCost() == null, $spell: castingSpell)
		$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
		$p: Player(id == $id)
		eval($spell.getStepCastingSpell().getObject().equals("601.2f"))
	then
		$spell.initializeTotalCost();
		$spell.getTotalCost().setManaCost($spell.getOriginCard().getManaCost().get(0));
		System.out.println("601.2f -> Settato Total Cost");
		$spell.getStepCastingSpell().next();
		update($g);
end

rule "601.2g"
	/* 
	November 19, 2021
	If the total cost includes a mana payment, the player then has a chance to activate mana abilities  (see rule 605, "Mana Abilities").
	Mana abilities must be activated before costs are paid. */
	agenda-group "general"
	dialect "mvel"
	when 
		$g: Game(stage == Game.GAME_STAGE, castingSpell != null, castingSpell.totalCost != null, castingSpell.sufficientMana == null,
		$spell: CastingSpell)
		$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
		$p: Player(id == $id)
		not ManaAbility()
		eval($spell.getStepCastingSpell().getObject().equals("601.2g"))
	then
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 60122;
		choice.choiceText = "Do you want to activate Mana Abilites?";
		choice.addOption(1, "Yes");
		choice.addOption(2, "No");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
		System.out.println("601.2g -> The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
		$spell.getStepCastingSpell().next();
end

rule "601.2g answerHandlerNo"
/*November 19, 2021*/
	agenda-group "general"
	dialect "mvel"
	when
		$g: Game(stage == Game.GAME_STAGE, $spell: castingSpell)
		$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60122, idPlayer == $id, idOptions.get(0) == 2)	
	then
		System.out.println("ManaPool: " + $p.printManaPool());
		System.out.println("ManaCost: " + $spell.printTotalCost());
		$spell.checkMana($p);
		if($spell.sufficientMana == true) {
			System.out.println("601.2g answerHandlerNo: Mana checked");
		} else {
			$g.setCastingSpell(null);
			retract($p.action);
			$p.action = new Action($id,0,0,0);
			insert($p.action);
			$p.hand.add($spell.originCard);
			$spell=null; // AGGIUNTA
			System.out.println("601.2g -> Insufficient Mana, Cast canceled");
			GameEngine.sendToNode("Insufficient Mana, Cast canceled");
		}	
		retract($ca);
		update($g);
end

rule "601.2g answerHandlerYes"
/*November 19, 2021*/
	agenda-group "general"

	when
		$g: Game(stage == Game.GAME_STAGE, $spell: castingSpell)
		$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60122, idPlayer == $id, idOptions.get(0) == 1)	
	then
		System.out.println("601.2g answerHandlerYes --> The player " + $p.getNickname() + " want activate mana abilities.");
		GameEngine.sendToNode("601.2g answerHandlerYes --> The player " + $p.getNickname() + " want activate mana abilities.");
		 
		MakeChoice choice = new MakeChoice();
		choice.setIdChoice(60123);
		choice.setChoiceText("Select the permanents you want tap");
		for (MagicObject mo : $g.getBattleField()) {
			Permanent p = (Permanent) mo;
			if (p.getIdController() == $id && !p.getStatus().isTapped()  && 
				p.getStatus().isFaceUp() && p.getStatus().isPhasedIn()) {
				LinkedList<Ability> abilities;
				if (!p.getStatus().isFlipped()) {
					abilities = p.getAbilities().get(0);
				} else {
					abilities = p.getAbilities().get(1);
				} 
				for (Ability abilita : abilities) {
					System.out.println("601.2g ability: " + abilita.getAbilityText());
					if (abilita.isMana_ability()){	//prima  era: ability.contains("to your mana pool")
						choice.addOption(p.getMagicTargetId(), 
							p.getNameAsString());
					}
				}
			}
		}
		
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.getNickname() + " has to decide which permanents wants tap");
		insert(new ManaAbility());
		retract($ca)
		update($g)
end
/*

						#ability.equals("{T}: Add {G} to your mana pool.") ||
						#ability.equals("{T}: Add {U} to your mana pool.") ||
						#ability.equals("{T}: Add {B} to your mana pool.") ||
						#ability.equals("{T}: Add {W} to your mana pool.") ||
						#ability.equals("{T}: Add {R} to your mana pool.") ||
						#ability.equals("{T}: Add {C} to your mana pool.") ||
						#ability.equals("G") ||
						#ability.equals("U") ||
						#ability.equals("B") ||
						#ability.equals("W") ||
						#ability.equals("R") ||
						#ability.equals("C")
*/
rule "601.2g answerHandlerMultiple"
/*November 19, 2021*/
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $spell: castingSpell)
		$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60123, idPlayer == $id)
		$ma: ManaAbility()
	then

		if ($ca.getIdOptions().size() > 0) {
			System.out.println("601.2g answerHandleMultiple --> The player " + $p.getNickname() + " has tapped some permanents.");
			for (String a : $ca.getIdOptions()) {
				for (MagicObject mo : $g.getBattleField()) {
					Permanent p = (Permanent) mo;
					if (a.equals(Integer.toString(p.getMagicTargetId()))) {
						p.getStatus().setTapped(true);	
						
						LinkedList<Ability> abilities;
						if (!p.getStatus().isFlipped()) {
							abilities = p.getAbilities().get(0);
						} else {
							abilities = p.getAbilities().get(1);
						}
						
						for (Ability abilita : abilities) {
							
							if (abilita.isMana_ability()) {
								String[] manaSymbols = {"{B}", "{G}", "{R}", "{U}", "{W}", "{C}"};
								String abilitaText = abilita.getAbilityText();
								String[] cuttedText = abilitaText.split("dd \\{"); 
								String refinedAbilitaText = "{" + cuttedText[1];								
								for (String manaSym : manaSymbols) {
									int count = -1, fromIndex = 0;
							        while ((fromIndex = refinedAbilitaText.indexOf(manaSym, fromIndex)) != -1 ){
							            count++;
							            fromIndex++;							            
							        }
									//int count = StringUtils.countMatches(refinedAbilitaText, manaSym);
									for (int i=0; i<=count; i++){
										$p.getManaPool().add(new Mana(new ManaSymbol(manaSym)));
									}
								}
							}							
						}
					}
				}
			}
		} else {
			System.out.println("601.2g answerHandleMultiple --> The player " + $p.getNickname() + " has not tapped permanents.");
		}
		$spell.checkMana($p);
		System.out.println("cast step: "+$spell.getStepCastingSpell().getObject());
		retract($ma)
		retract($ca)
		update($g)
end
/*
							if (ability.equals("{T}: Add {G} to your mana pool.") || ability.equals("G")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{G}")));
							} else if (ability.equals("{T}: Add {U} to your mana pool.") || ability.equals("U")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{U}")));
							} else if (ability.equals("{T}: Add {W} to your mana pool.") || ability.equals("W")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{W}")));
							} else if (ability.equals("{T}: Add {B} to your mana pool.") || ability.equals("B")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{B}")));
							} else if (ability.equals("{T}: Add {R} to your mana pool.") || ability.equals("R")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{R}")));
							} else {
								$p.getManaPool().add(new Mana(new ManaSymbol("{C}")));
							}
*/



rule "601.2h"
//martina-damiano aggiunta del cast di tipo MagicObject al tipo Spell per poter applicare funzioni di getid del target nelle fasi successive del gioco
/* 
601.2h
The player pays the total cost in any order. Partial payments are not allowed. 
Unpayable costs can't be paid. 
*/
/*
November 19, 2021
The player pays the total cost. First, they pay all costs that don't involve random elements or moving objects from the library to a public 
zone, in any order. Then they pay all remaining costs in any order. Partial payments are not allowed. Unpayable costs can't be paid.
*/
agenda-group "general"
dialect "mvel"
when 
	$g: Game(stage == Game.GAME_STAGE, castingSpell != null, castingSpell.sufficientMana == true, $stack: stack, $spell: castingSpell)
	$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
	$p: Player(id == $id)
	eval($spell.stepCastingSpell.getObject().equals("601.2h"))
then
	System.out.println("601.2h");
	if($spell.getCountSelectableMana() > 0) {
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 60124;
		choice.choiceText = "Select " + $spell.getCountSelectableMana() + " Mana you want to use";
		for(Mana m : $spell.getSelectableMana($p)) {
			System.out.println("rule for");
			choice.addOption(m.color, m.color);
		}
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " has to decide Mana to pay.");
		System.out.println("601.2h -> The player " + $p.nickname + " has to decide Mana to pay.");
	} else {
		$spell.payMana($p);
		$stack.addFirst((MagicObject) $spell); 
		$g.setCastingSpell(null);
				
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
		}
		GameEngine.sendToNode("Cast Done");
		update($g);
	}
end


rule "601.2h answerHandler & 601.2i"
//TODO: gestire triggered abilities
/*
November 19, 2021
601.2h answerHandler
/*
/*November 19, 2021
601.2i. Once the steps described in 601.2a-h are completed, effects that modify the 
characteristics of the spell as it's cast are applied, 
then the spell becomes cast. Any abilities that trigger when a spell is cast or put 
onto the stack trigger at this time. If the spell's 
controller had priority before casting it, they get priority.
*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $stack: stack, $spell: castingSpell)
	$act: Action($id: id, option == Game.CAST_INSTANT_SPELL || option == Game.CAST_NON_INSTANT_SPELL)
	$p: Player(id == $id)
	$ca: ChoiceAnswer(idChoice == 60124, idPlayer == $id)	
then
	System.out.println("601.2h fase 2");
	if($ca.idOptions.size() == $spell.getCountSelectableMana()) {
		for(String s : $ca.idOptions) {
			boolean found = false;
			for(Mana m : $spell.totalCost.manaCost) {				
				if(m.getType().equals("colorless") && !found) {
					m.setType(s);
					m.setColor(s);
					found = true;
				}
			}
		}
		$spell.payMana($p);
		System.out.println("ManaPool 2: " + $p.printManaPool());
		$stack.addFirst($spell);
		$g.setCastingSpell(null);
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
		}
		GameEngine.sendToNode("Cast Done");
	} else {
		$g.setCastingSpell(null);
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
		$p.hand.add($spell.originCard);
		System.out.println("601.2g -> Incorrect Mana, Cast canceled");
		GameEngine.sendToNode("Incorrect Mana, Cast canceled");
	}
	retract($ca);
	update($g);
end





// Activated Ability

//martina-damiano proposta delle abilità attivate al giocatore, se è un as_a_sorcery controllo se sono il giocatore attivo
// le abilità non hanno un id, è stato generato un id fittizio composto da: idcarta+header+numeroabilitàcarta 
//numeroabilitàcarta indica se è la prima, la seconda... abilità contenuta nella carta 

rule "602.2"
/*
November 19, 2021
To activate an ability is to put it onto the stack and pay its costs, so that it will eventually resolve and have its effect. 
Only an object's controller (or its owner, if it doesn't have a controller) can activate its activated ability unless the object specifically says otherwise. 
Activating an ability follows the steps listed below, in order. If, at any point during the activation of an ability, a player is unable 
to comply with any of those steps, the activation is illegal; the game returns to the moment before that ability started to be activated 
Announcements and payments can't be altered after they've been made.*/	
agenda-group "general"
when 
	$g: Game(stage == Game.GAME_STAGE, activeAbility == null, $b: battleField)
	$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
	$p: Player(id == $id)
then
	MakeChoice choice = new MakeChoice();
	choice.setIdChoice(60221);
	choice.setChoiceText("Choose which ability to play");	
	boolean found = false;
	String header="09890";	
	for(MagicObject mo : $b) {		
		//se è una mia carta controllo che non sia sorcery e continuo cosi
		//se mia carta ma sorcery allora controllo che sono player attivo		
		if(mo.getIdController() == $id){
			LinkedList<Ability> ab = mo.getAbilities().get(0);
			int id = 0;
			for(Ability a : ab){
				if(a.isActivated_ability()){
					if(a.isAs_a_sorcery() && $id==$g.getActivePlayer().getObject().getId()){ // se è una as a sorcery devo essere giocatore attivo
						choice.addOption(mo.getMagicTargetId()+header+id,mo.getName() + " : "+ a.getAbilityText());
						found = true;
					}
					else{
						choice.addOption(mo.getMagicTargetId()+header+id,mo.getName() + " : "+ a.getAbilityText());
						found = true;
					}
				}
				id++;
			}			
		}	
	}	
	if(found) {
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.getNickname() + " wants activate ability.");
		System.out.println("The player " + $p.getNickname() + " wants activate ability.");
	} else {
		GameEngine.sendToNode("You have not ability to activate.");
		System.out.println("602.2 -> The player " + $p.getNickname() + "  has not ability to activate.");
		retract($p.getAction());
		$p.setAction(new Action($id,0,0,0));
		insert($p.getAction());
	}		
	
end
	

rule "602.2a answerHandler"	
//martina-damiano una volta scelta l'abilità da attivare si crea l'abilityonthestack corrispondente e si inserisce nello stack di attivazione
//l'id dell'abilità e della carta si ottengono tramite lo split del messaggio composto da idcarta+header+numeroabilitàcarta 
/*
November 19, 2021
The player announces that they are activating the ability. If an activated ability is being activated from a hidden zone, the card that has that 
ability is revealed. That ability is created on the stack as an object that's not a card. It becomes the topmost object on the stack. 
It has the text of the ability that created it, and no other characteristics. Its controller is the player who activated the ability. 
The ability remains on the stack until it's countered, it resolves, or an effect moves it elsewhere.*/
agenda-group "general"
when
	$g: Game(stage == Game.GAME_STAGE, activeAbility==null, $b: battleField)
	$act: Action($id: id, $option:option, option == Game.ACTIVATE_ABILITY)
	$p: Player(id == $id)
	$ca: ChoiceAnswer(idChoice == 60221, idPlayer == $id)
then
	String header="09890";
	String[] messaggio = ($ca.getIdOptions().get(0)+"").split(header);
	int idCarta	= Integer.parseInt(messaggio[0]);
	int idAbilita = Integer.parseInt(messaggio[1]);

	MagicObject c = null;
	for(MagicObject mo : $b) {
		if(mo.getMagicTargetId() == idCarta)
		{
			AbilityOnTheStack aos;
			if(mo.getAbilities() != null){
				LinkedList<Ability> ab = mo.getAbilities().get(0); //solo faccia 0
				int id = 0;
				for(Ability a : ab){
					if(id == idAbilita){
						aos = new AbilityOnTheStack(a, idCarta, mo, $id, $id, $g.getIdStackCounter()); //da rivedere costruttore
						$g.setActiveAbility(aos);
					}
					id++;
				}
				
			}
			c=mo;
			
		}
	}
	$p.getHand().remove(c);
	GameEngine.sendToNode("The player " + $p.getNickname() + " choosen to activate " + $g.getActiveAbility()); //nome non c'è
	System.out.println("602.2a -> The player " + $p.getNickname() + " choosen to activate " +$g.getActiveAbility()); //nome non c'è
	retract($ca);
	update($g);
	
end


rule "602.2b fasi"
//martina-damiano definizione delle fasi a seconda se l'abilità da attivare ha il target o meno
/* 
November 19, 2021
The remainder of the process for activating an ability is identical to the process for casting a spell listed in rules 601.2b-i. 
Those rules apply to activating an ability just as they apply to casting a spell. An activated ability's analog to a spell's mana cost 
is its activation cost.*/
agenda-group "general"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getActiveAbility()!=null)
	$ab: AbilityOnTheStack($id : controller, $saa: stepActivateAbility.listReference) from $g.getActiveAbility()	
	eval($saa.size() == 0)
	$p: Player(id == $id)
then
	if($ab.isTargetted_ability()){
		System.out.println("abilita con target");
		$saa.add("602.2cfase1");
		$saa.add("602.2cfase2");	
	}
	
	////da aggiungere 
	//$saa.add("602.2d");
	//$saa.add("602.2e");
	$saa.add("602.2f");
	$saa.add("602.2g");
	$saa.add("602.2h");
	
	$ab.getStepActivateAbility().next();
	update($g);			
end	

rule "602.2cfase1"
//martina-damiano proposta di tutte i possibili target (in tutte le zone) al giocatore, il messaggio che viene inviato è composto da
//se target carta numerozona+header+idcarta questo perchè ci permette di tenere traccia della zona da cui è stato selezionato il target
//se target zona numero+header+idzona
//se target giocatore numero+header+idplayer
/*November 19, 2021*/
agenda-group "general"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getActiveAbility() != null)
	$ab: AbilityOnTheStack(targetted_id == null, $id : controller, $saa: getStepActivateAbility()) from $g.getActiveAbility()	
	$p: Player(id == $id)
	eval($ab.getStepActivateAbility().getObject().equals("602.2cfase1"))
then
	System.out.println("601.2c: si deve selezionare i target dell'abilità");
	int debug=1;
		
	if($ab.getTargetType() != null){
		MakeChoice nchoice = new MakeChoice();
		nchoice.setIdChoice(602231);
		nchoice.setChoiceText("Choose target for Ability: "+$ab.getAbilityText());
		System.out.println("Choose target for "+$ab);
		String header="09890";	
		for(String tipoTarget : $ab.getTargetType()){
			
			//Pietro: forse bisogna fare la stessa modifica per i sottotipi, già fatta alle spell
			
			for(MagicObject nmo : $g.getBattleField()){
			//System.out.println(nmo.getCardType().get(0).get(0)); torna ad esempio land invece che island
				if(nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){ 
					int idInviato=Integer.parseInt(""+1+header+nmo.getMagicTargetId());
					nchoice.addOption(idInviato, nmo.getName().get(0));
				}
			}
	
			for (MagicObject nmo : $g.getExile()) {
				if(nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
					int idInviato=Integer.parseInt(""+2+header+nmo.getMagicTargetId());
					nchoice.addOption(idInviato, nmo.getName().get(0));
				}
			}
	
			for (MagicObject nmo : $g.getStack()) {
				if(nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
					int idInviato=Integer.parseInt(""+3+header+nmo.getMagicTargetId());
					nchoice.addOption(idInviato, nmo.getName().get(0));
				}
			}	
			
			for (MagicObject nmo : $g.getCommand()) {
				if(nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
					int idInviato=Integer.parseInt(""+4+header+nmo.getMagicTargetId());
					nchoice.addOption(idInviato, nmo.getName().get(0));
				}
			}	
	
			for (MagicObject nmo : $g.getAnte()) {
				if(nmo.getCardType().get(0).get(0).toLowerCase().equals(tipoTarget.toLowerCase())){
					int idInviato=Integer.parseInt(""+5+header+nmo.getMagicTargetId());
					nchoice.addOption(idInviato, nmo.getName().get(0));
				}
			}
			 
			if(tipoTarget.toLowerCase().equals("stack")){
				int idInviato=Integer.parseInt(""+6+header+$g.getStack().getMagicTargetId());
				nchoice.addOption(idInviato, "stack");
			}
			if(tipoTarget.toLowerCase().equals("battlefield")){
				int idInviato=Integer.parseInt(""+6+header+$g.getBattleField().getMagicTargetId());
				nchoice.addOption(idInviato, "battlefield");
			}
			if(tipoTarget.toLowerCase().equals("exile")){
				int idInviato=Integer.parseInt(""+6+header+$g.getExile().getMagicTargetId());
				nchoice.addOption(idInviato, "exile");
			}
			if(tipoTarget.toLowerCase().equals("command")){
				int idInviato=Integer.parseInt(""+6+header+$g.getCommand().getMagicTargetId());
				nchoice.addOption(idInviato, "command");
			}	
			if(tipoTarget.toLowerCase().equals("ante")){
				int idInviato=Integer.parseInt(""+6+header+$g.getAnte().getMagicTargetId());
				nchoice.addOption(idInviato, "ante");
			}			
				
			if(tipoTarget.toLowerCase().equals("player")){
				for (Player p : $g.getPlayers()) {
					int idInviato=Integer.parseInt(""+7+header+p.getMagicTargetId());
					nchoice.addOption(idInviato, p.getNickname());
				}				
			}	
																	
			if (nchoice.getChoiceOptions().size() > 0) {
				System.out.println("Target papabili : " + nchoice.getChoiceOptions().size());
				GameEngine.sendToNode(nchoice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);  //NOTA DEVONO ESSERE GESTITI PIU TARGET!
			}else{		
				System.out.println("Errore 602.2c tipo 2");
			}				
		}
		
	}else{
		System.out.println("Errore 602.2c tipo 1");
	}	
	$saa.next();
	update($g);
end


rule "602.2cfase2"
//martina-damiano aggiunta del target alla carta dopo che è stata scelta dal giocatore
//a seconda dell'id precedentemente inviato conosco il tipo di target e lo aggiungo all'abilityonthestack
/*November 19, 2021*/
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $g.getActiveAbility()!=null)
	$ca: ChoiceAnswer(idChoice == 602231, $op : idOptions, $op!=null)
	$ab: AbilityOnTheStack(targetted_id == null, $id : controller, $saa: getStepActivateAbility()) from $g.getActiveAbility()	
	$p: Player(id == $id)
	eval($ab.getStepActivateAbility().getObject().equals("602.2cfase2"))
then
	System.out.println("602.2c fase 2: aggiunta del target alla carta");
	String header="09890";	
	String[] selezioneUtente = ($op.get(0)+"").split(header);
	int zona		=	Integer.parseInt(selezioneUtente[0]);
	int idCartaTo	=	Integer.parseInt(selezioneUtente[1]);
	System.out.println("TARGET:");
	System.out.println(idCartaTo);
	System.out.println($op.toString());
	MagicObject cto	= 	null;
	int trovato		= 0;
	if(zona==1){
		for (MagicObject mo : $g.getBattleField()) {
			if(mo.getMagicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==2){
		for (MagicObject mo : $g.getExile()) {
			if(mo.getMagicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==3){
		for (MagicObject mo : $g.getStack()) {
			if(mo.getMagicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==4){
		for (MagicObject mo : $g.getCommand()) {
			if(mo.getMagicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==5){ 
		for (MagicObject mo : $g.getAnte()) {
			if(mo.getMagicTargetId==idCartaTo){
				cto=mo;
				trovato=1;
			}	
		}
	}
	if(zona==6){
		if(idCartaTo==$g.getBattleField().getMagicTargetId()){
			cto=$g.getBattleField();
			trovato=1;
		}
		if(idCartaTo==$g.getCommand().getMagicTargetId()){
			cto=$g.getCommand();
			trovato=1;
		}
		if(idCartaTo==$g.getAnte().getMagicTargetId()){
			cto=$g.getAnte();
			trovato=1;
		}
		if(idCartaTo==$g.getExile().getMagicTargetId()){
			cto=$g.getExile();
			trovato=1;
		}
		if(idCartaTo==$g.getStack().getMagicTargetId()){
			cto=$g.getStack();
			trovato=1;
		}	
	}		
	if(zona==7){ 
		for (Player p : $g.getPlayers()) {
			if(p.getMagicTargetId()==idCartaTo){
				cto=p;
				trovato=1;
			}	
		}
	}
	if(trovato==1){
		//System.out.println("id Target " + idCartaTo + " oggetto "+ cto.getMagicTargetId);
		$ab.addOneTargetted_id(idCartaTo);
		GameEngine.sendToNode("The player " + $p.getNickname() + " has selected the target !");
		$saa.next();
	}
	if(trovato==0){
		System.out.println("Errore: target non aggiunto, carta non trovata!");	
	}		
	retract($ca)	
	update($g);
end


rule "602.2f"
//martina-damiano
/*November 19, 2021*/
	agenda-group "general"
	when 
		$g: Game(stage == Game.GAME_STAGE, activeAbility != null, activeAbility.getTotalCost() == null, $ab: activeAbility)
		$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id == $id)
		eval($ab.getStepActivateAbility().getObject().equals("602.2f"))
	then
		//$ab.getTotalCost().setManaCost($ab.getOriginCard().getManaCost().get(0));
		$ab.initializeTotalCost();
		$ab.getTotalCost().setManaCost();
		System.out.println("602.2f -> Settato Total Cost: "+$ab.getTotalCost().getManaCost());
		$ab.getStepActivateAbility().next();
		update($g);
end


rule "602.2g"
//martina-damiano
/*November 19, 2021*/
	agenda-group "general"
	dialect "mvel"
	when 
		$g: Game(stage == Game.GAME_STAGE, activeAbility != null, activeAbility.totalCost != null, activeAbility.sufficientMana == null,
		$ab: activeAbility)
		$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id == $id)
		not ManaAbility()
		eval($ab.getStepActivateAbility().getObject().equals("602.2g"))
	then
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 60222;
		choice.choiceText = "Do you want to activate Mana Abilites?";
		choice.addOption(1, "Yes");
		choice.addOption(2, "No");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
		System.out.println("602.2g -> The player " + $p.nickname + " has to decide if he want activate Mana Abilities.");
		$ab.getStepActivateAbility().next();
end



rule "602.2g answerHandlerNo"
//martina-damiano
/*November 19, 2021*/
	agenda-group "general"
	dialect "mvel"
	when
		$g: Game(stage == Game.GAME_STAGE, $ab: activeAbility)
		$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60222, idPlayer == $id, idOptions.get(0) == 2)	
	then
		System.out.println("ManaPool: " + $p.printManaPool());
		System.out.println("ManaCost: " + $ab.printTotalCost());
		$ab.checkMana($p);
		if($ab.sufficientMana == true) {
			System.out.println("602.2g answerHandlerNo: Mana checked");
		} else {
			$g.setActiveAbility(null);
			retract($p.action);
			$p.action = new Action($id,0,0,0);
			insert($p.action);
			$p.hand.add($ab.originCard);
			$ab=null; // AGGIUNTA
			System.out.println("602.2g -> Insufficient Mana, Cast canceled");
			GameEngine.sendToNode("Insufficient Mana, Cast canceled");
		}	
		retract($ca);
		update($g);
end


rule "602.2g answerHandlerYes"
//martina-damiano
/*November 19, 2021*/
	agenda-group "general"

	when
		$g: Game(stage == Game.GAME_STAGE, $ab: activeAbility)
		$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60222, idPlayer == $id, idOptions.get(0) == 1)	
	then
		System.out.println("602.2g answerHandlerYes --> The player " + $p.getNickname() + " want activate mana abilities.");
		GameEngine.sendToNode("601.2g answerHandlerYes --> The player " + $p.getNickname() + " want activate mana abilities.");
		 
		MakeChoice choice = new MakeChoice();
		choice.setIdChoice(60223);
		choice.setChoiceText("Select the permanents you want tap");
		for (MagicObject mo : $g.getBattleField()) {
			Permanent p = (Permanent) mo;
			if (p.getIdController() == $id && !p.getStatus().isTapped()  && 
				p.getStatus().isFaceUp() && p.getStatus().isPhasedIn()) {
				
				LinkedList<Ability> abilities;
				if (!p.getStatus().isFlipped()) {
					abilities = p.getAbilities().get(0);
				} else {
					abilities = p.getAbilities().get(1);
				} 

				// Modificare in futuro nel caso in cui devono essere gestiti
				// più ManaSymbol.
				for (Ability abilita : abilities) { // vedere solo se il booleano è a true
					//String ability=abilita.getAbilityText();
					System.out.println("602.2g ability: " + abilita.getAbilityText());
					
					if (
						abilita.isMana_ability()	
						){ 			//ability.contains("to your mana pool")
						choice.addOption(p.getMagicTargetId(), 
							p.getNameAsString());
						
					}
				}
				
			}
		}
		
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.getNickname() + " has to decide which permanents wants tap");
		insert(new ManaAbility());
		retract($ca)
		update($g)
end
/*

						#ability.equals("{T}: Add {G} to your mana pool.") ||
						#ability.equals("{T}: Add {U} to your mana pool.") ||
						#ability.equals("{T}: Add {B} to your mana pool.") ||
						#ability.equals("{T}: Add {W} to your mana pool.") ||
						#ability.equals("{T}: Add {R} to your mana pool.") ||
						#ability.equals("{T}: Add {C} to your mana pool.") ||
						#ability.equals("G") ||
						#ability.equals("U") ||
						#ability.equals("B") ||
						#ability.equals("W") ||
						#ability.equals("R") ||
						#ability.equals("C")
*/


rule "602.2g answerHandlerMultiple"
//martina-damiano
/*November 19, 2021*/
	agenda-group "general"
	
	when
		$g: Game(stage == Game.GAME_STAGE, $ab: activeAbility)
		$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
		$p: Player(id == $id)
		$ca: ChoiceAnswer(idChoice == 60223, idPlayer == $id)
		$ma: ManaAbility()
	then

		if ($ca.getIdOptions().size() > 0) {
			System.out.println("602.2g answerHandleMultiple --> The player " + $p.getNickname() + " has tapped some permanents.");
			for (String a : $ca.getIdOptions()) {
				for (MagicObject mo : $g.getBattleField()) {
					Permanent p = (Permanent) mo;
					if (a.equals(Integer.toString(p.getMagicTargetId()))) {
						p.getStatus().setTapped(true);	
						
						LinkedList<Ability> abilities;
						if (!p.getStatus().isFlipped()) {
							abilities = p.getAbilities().get(0);
						} else {
							abilities = p.getAbilities().get(1);
						}
						
						for (Ability abilita : abilities) {
							
							if (abilita.isMana_ability()) {
								String[] manaSymbols = {"{B}", "{G}", "{R}", "{U}", "{W}", "{C}"};
								String abilitaText = abilita.getAbilityText();
								String[] cuttedText = abilitaText.split("dd \\{"); 
								String refinedAbilitaText = "{" + cuttedText[1];								
								for (String manaSym : manaSymbols) {
									int count = -1, fromIndex = 0;
							        while ((fromIndex = refinedAbilitaText.indexOf(manaSym, fromIndex)) != -1 ){
							            count++;
							            fromIndex++;							            
							        }
									//int count = StringUtils.countMatches(refinedAbilitaText, manaSym);
									for (int i=0; i<=count; i++){
										$p.getManaPool().add(new Mana(new ManaSymbol(manaSym)));
									}
								}
							}							
						}
					}
				}
			}
		} else {
			System.out.println("602.2g answerHandleMultiple --> The player " + $p.getNickname() + " has not tapped permanents.");
		}
		$ab.checkMana($p);
		retract($ma)
		retract($ca)
		update($g)
end
/*
							if (ability.equals("{T}: Add {G} to your mana pool.") || ability.equals("G")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{G}")));
							} else if (ability.equals("{T}: Add {U} to your mana pool.") || ability.equals("U")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{U}")));
							} else if (ability.equals("{T}: Add {W} to your mana pool.") || ability.equals("W")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{W}")));
							} else if (ability.equals("{T}: Add {B} to your mana pool.") || ability.equals("B")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{B}")));
							} else if (ability.equals("{T}: Add {R} to your mana pool.") || ability.equals("R")) {
								$p.getManaPool().add(new Mana(new ManaSymbol("{R}")));
							} else {
								$p.getManaPool().add(new Mana(new ManaSymbol("{C}")));
							}
*/


rule "602.2h"
//martina-damiano
/*November 19, 2021*/
agenda-group "general"
dialect "mvel"
when 
	$g: Game(stage == Game.GAME_STAGE, activeAbility != null, activeAbility.sufficientMana == true, $stack: stack, $ab: activeAbility)
	$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
	$p: Player(id == $id)
	eval($ab.getStepActivateAbility().getObject().equals("602.2h"))
then
	System.out.println("602.2h");
	if($ab.getCountSelectableMana() > 0) {
		System.out.println("602.2h debug 1");
		MakeChoice choice = new MakeChoice();
		choice.idChoice = 60224;
		choice.choiceText = "Select " + $ab.getCountSelectableMana() + " Mana you want to use";
		if($ab.getSelectableMana($p)!= null){
			for(Mana m : $ab.getSelectableMana($p)) {
				choice.addOption(m.color, m.color);
			}
		
		System.out.println("602.2h debug 2");
		GameEngine.sendToNode(choice, Game.CHOICE, Game.MULTIPLE_CHOICE, $id);
		GameEngine.sendToNode("The player " + $p.nickname + " has to decide Mana to pay.");
		System.out.println("602.2h -> The player " + $p.nickname + " has to decide Mana to pay.");
		}
	} else {
		System.out.println("602.2h debug 3");
		$ab.payMana($p);			
		System.out.println("602.2h debug 4");
		$stack.addFirst((MagicObject) $ab); 	
		$g.setActiveAbility(null);
		
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
		}
		GameEngine.sendToNode("Cast Done");
		update($g);
	}
end



rule "602.2h answerHandler & 602.2i"
//martina-damiano
/*November 19, 2021*/

//TODO: gestire triggered abilities
agenda-group "general"
dialect "mvel"
when
	$g: Game(stage == Game.GAME_STAGE, $stack: stack, $ab: activeAbility)
	$act: Action($id: id, option == Game.ACTIVATE_ABILITY)
	$p: Player(id == $id)
	$ca: ChoiceAnswer(idChoice == 60224, idPlayer == $id)	
then
	System.out.println("602.2h fase 2");
	if($ca.idOptions.size() == $ab.getCountSelectableMana()) {
		for(String s : $ca.idOptions) {
			boolean found = false;
			for(Mana m : $ab.totalCost.manaCost) {				
				if(m.getType().equals("colorless") && !found) {
					m.setType(s);
					m.setColor(s);
					found = true;
				}
			}
		}
		$ab.payMana($p);
		System.out.println("ManaPool 2: " + $p.printManaPool());
		$stack.addFirst((MagicObject) $ab);
		$g.setActiveAbility(null);
		for(Player p : $g.priorityOrder){
			retract(p.action);
			p.action = new Action(p.id,0,0,0);
			insert(p.action);
		}
		GameEngine.sendToNode("Cast Done");
	} else {
		$g.setActiveAbility(null);
		retract($p.action);
		$p.action = new Action($id,0,0,0);
		insert($p.action);
		$p.hand.add($ab.originCard);
		System.out.println("602.2g -> Incorrect Mana, Cast canceled");
		GameEngine.sendToNode("Incorrect Mana, Cast canceled");
	}
	retract($ca);
	update($g);
end


rule "608.1"
/*
November 19, 2021
608.1 
Each time all players pass in succession, the spell or ability on top of the stack resolves  
(See rule 609, "Effects."). 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, $stack: stack, !$stack.isEmpty(), resolvedSpell == false, stepTimeFrame==Game.DURING_TIME_FRAME || phaseTimeFrame==Game.DURING_TIME_FRAME, resolvingSpell == null) 		
		forall( Player($id : id) Action(id==$id , option==Game.PASS_PRIORITY) )	
		
	then
		System.out.println("608.1 risoluzione stack");
		Object o = $stack.pop();
		if(o instanceof Spell){
			System.out.println("608.1 -> Starting resolving spell");
			$g.resolvingSpell = (Spell) o;
			$g.resolvingAbility = null;
			GameEngine.sendToNode("Resolving Spell");
		}
		if(o instanceof AbilityOnTheStack){
			System.out.println("608.1 -> Starting resolving ability");
			$g.resolvingAbility = (AbilityOnTheStack) o;
			$g.resolvingSpell = null;
			GameEngine.sendToNode("Resolving Ability");
		}
		update($g); 		 	
end



rule "608.2"

/*
November 19, 2021
	L'ORDINE E': 602.2a, 602.2b -> 608.2c, ..., 608.2k -> 608.2m
608.2
If the object that's resolving is an instant spell, a sorcery spell, or an ability, its resolution may involve several steps. 
The steps described in rules 608.2a and 608.2b are followed first. The steps described in rules 608.2c-k are then followed as appropriate, 
in no specific order. The step described in rule 608.2m is followed last.
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game( stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == null, $id: resolvingSpell.idController,
				resolvingSpell.cardType[0].contains("instant") || resolvingSpell.cardType[0].contains("sorcery") || resolvingSpell.cardType[0].contains("ability"))
		$p: Player(id == $id)
	then
		$g.resolvingSpell.isPermanent = false;
		System.out.println("608.2 -> The resolving spell isn't a permanent");
		update($g); 		 	
end


rule "608.2a"
/* 
November 19, 2021
608.2a
If a triggered ability has an intervening "if" clause, it checks whether the clause's condition is true. 
If it isn't, the ability is removed from the stack and does nothing. Otherwise, it continues to resolve. 
See rule 603.4.
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end



rule "608.2b Ability"

/*
November 19, 2021
608.2b
If the spell or ability specifies targets, it checks whether the targets are still legal. A target that's no longer in the zone it was in 
when it was targeted is illegal. Other changes to the game state may cause a target to no longer be legal; for example, its characteristics 
may have changed or an effect may have changed the text of the spell. If the source of an ability has left the zone it was in, its last 
known information is used during this process. If all its targets, for every instance of the word "target," are now illegal, the spell or 
ability doesn't resolve. It's removed from the stack and, if it's a spell, put into its owner's graveyard. Otherwise, the spell or ability 
will resolve normally. Illegal targets, if any, won't be affected by parts of a resolving spell's effect for which they're illegal. Other 
parts of the effect for which those targets are not illegal may still affect them. If the spell or ability creates any continuous effects 
that affect game rules (see rule 613.11), those effects don't apply to illegal targets. If part of the effect requires information about an 
illegal target, it fails to determine any such information. Any part of the effect that requires that information won't happen
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingAbility != null, $b: battleField, resolvingAbility.targetted_ability == true)
	then
		//Se i target settati nell'ability on the stack sono ancora sul battlefield, allora setta valido.
		LinkedList targettedList = $g.resolvingAbility.getTargetted_id();
		if(targettedList != null){
			for(Integer id: targettedList){
				//Controlla che il permanent con ID == id sia ancora nel battlefield
				for(Permanent per: $b){
					if(per.getMagicTargetId() == id){
						//Setto vald target a true se trovo l'id, settato in precedenza, ancora nel battlefield.
						$g.resolvingAbility.setValidTarget(true);
					}
				}
			}
		}
		
			 	
end



rule "608.2b Spell"
/*November 19, 2021*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		//Target delle Spell
			 	
end



rule "608.2c"
/* 
November 19, 2021
608.2c
The controller of the spell or ability follows its instructions in the order written. However, replacement 
effects may modify these actions. In some cases, later text on the card may modify the meaning of earlier text 
(for example, "Destroy target creature. It can't be regenerated" or "Counter target spell. If that spell is countered 
this way, put it on top of its owner's library instead of into its owner's graveyard.") Don't just apply effects step 
by step without thinking in these cases--read the whole text and apply the rules of English to the text. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end



rule "608.2d"
/* 
November 19, 2021
608.2d
If an effect of a spell or ability offers any choices other than choices already made as part of casting the spell, 
activating the ability, or otherwise putting the spell or ability on the stack, the player announces these while 
applying the effect. The player can't choose an option that's illegal or impossible, with the exception that having 
a library with no cards in it doesn't make drawing a card an impossible action (see rule 121.3). If an effect divides 
or distributes something, such as damage or counters, as a player chooses among any number of untargeted players and/or 
objects, the player chooses the amount and division such that at least one player or object is chosen if able, and each 
chosen player or object receives at least one of whatever is being divided. (Note that if an effect divides or 
distributes something, such as damage or counters, as a player chooses among some number of target objects 
and/or players, the amount and division were determined as the spell or ability was put onto the stack 
rather than at this time; see rule 601.2d.) 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end



rule "608.2e"
/* 
November 19, 2021
608.2e
Some spells and abilities have multiple steps or actions, denoted by separate sentences or clauses, that involve 
multiple players. In these cases, the choices for the first action are made in APNAP order, and then the first action 
is processed simultaneously. Then the choices for the second action are made in APNAP order, and then that action is 
processed simultaneously, and so on. See rule 101.4. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end

//TODO
//rule 608.2f





rule "608.2g"
/* 
November 19, 2021
	
608.2g
If an effect gives a player the option to pay mana, he or she may activate mana abilities before taking that action. 
If an effect specifically instructs or allows a player to cast a spell during resolution, he or she does so by following 
the steps in rules 601.2a-i, except no player receives priority after it's cast. That spell becomes the topmost object on 
the stack, and the currently resolving spell or ability continues to resolve, which may include casting other spells this 
way. No other spells can normally be cast and no other abilities can normally be activated during resolution. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end



rule "608.2h"
/* 
November 19, 2021
608.2h
If an effect requires information from the game (such as the number of creatures on the battlefield), the answer is 
determined only once, when the effect is applied. If the effect requires information from a specific object, including 
the source of the ability itself or a target that's become illegal, the effect uses the current information of that 
object if it's in the public zone it was expected to be in; if it's no longer in that zone, or if the effect has 
moved it from a public zone to a hidden zone, the effect uses the object's last known information. See rule 112.7a. 
If an ability states that an object does something, it's the object as it exists--or as it most recently existed--that 
does it, not the ability. 
NEW If an effect requires information from the game (such as the number of creatures on the battlefield), 
the answer is determined only once, when the effect is applied. If the effect requires information from a specific
object, including the source of the ability itself, the effect uses the current information of that object if 
it's in the public zone it was expected to be in; if it's no longer in that zone, or if the effect has moved it 
from a public zone to a hidden zone, the effect uses the object's last known information. See rule 113.7a. 
If an ability states that an object does something, it's the object as it exists--or as it most recently 
existed--that does it, not the ability.
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end


rule "608.2i"
/* 
November 19, 2021
608.2i
If an effect refers to certain characteristics, it checks only for the value of the specified characteristics, 
regardless of any related ones an object may also have. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end


rule "608.2j"
/*  
November 19, 2021
608.2j
If an ability's effect refers to a specific untargeted object that has been previously referred to by that ability's 
cost or trigger condition, it still affects that object even if the object has changed characteristics.
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end



rule "608.2k"
/*  
November 19, 2021
608.2k
If an instant spell, sorcery spell, or ability that can legally resolve leaves the stack once it starts to resolve, 
it will continue to resolve fully. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == false, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		// Da implementare con le carte 		 	
end

/* 
November 19, 2021
608.2m Ability/Spell
As the final part of an instant or sorcery spell's resolution, the spell is put into its owner's graveyard. 
As the final part of an ability's resolution, the ability is removed from the stack and ceases to exist. 
*/
//Pietro: separato il processo di risoluzione di istant e sorcery da ability
rule "608.2m Ability"
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingAbility != null, $b: battleField)
	then
		
		if($g.resolvingAbility.getValidTarget() == true){
			// Se il target risulta valido scorro i permanent sul battlefield
			for(Permanent artifact : $b){	
				if(artifact.cardType[0].contains("artifact")){
					// Se il permanent è un artifact scorro il battlefield alla ricerca del permanent che devo attachare
					for(Permanent aos_target: $b){
						int count = 0;
						// Cerco il permanent che ha un id uguale all'id che c'è nella lista targettted_id
						for(Integer idt : $g.resolvingAbility.getTargetted_id()){
							if(aos_target.getMagicTargetId() == idt){
								artifact.attached_to.add(idt); //Quando lo trovo,  lo aggiungo alla lista di attached_to
								aos_target.attached_by.add(artifact.getMagicTargetId()); //Metto nella lista di attached by l'id del permanent che fa l'attach
								aos_target.attby_perm.add(artifact); 
								$g.resolvingAbility.setValidTarget(false); //Imposto il target non più valido per questo permanent
								$g.resolvingAbility.getTargetted_id().remove(count); //Tolgo dalla lista targetted, il permanent che ho appena attachato
								
								//Non bisogna fare la pop dallo stack perché l'ho già fatta nella 608.1
								
								System.out.println("608.2m -> The resolved spell was an Ability Spell: it ceases to exist");
								GameEngine.sendToNode("Spell Ability resolved ceases to exist");
							}
						count++;
						}	
					} 
				}
			}
		}else{
			//Se il permanent non è più valido setto la resolving a false
			$g.resolvingAbility = null; 
			System.out.println("608.2m -> Ability resolved: target no more valid");
			GameEngine.sendToNode("608.2m -> Ability resolved: target no more valid");
		}
		update($g);
end


rule "608.2m Spell"
/*
November 19, 2021
608.2m 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == null, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		if($g.resolvingSpell.cardType[0].contains("instant") || $g.resolvingSpell.cardType[0].contains("sorcery")) {
			$g.resolvingSpell.originCard.idGraveyard = $g.getIdGraveyardCounter();
			$p.graveyard.add($g.resolvingSpell.originCard);
			$g.resolvingSpell = null;
			$g.resolvedSpell = true;
			System.out.println("608.2m -> The resolved spell was an Instant or a Sorcery Spell: it goes in the graveyard");
			GameEngine.sendToNode("Instant or a Sorcery Spell resolved goes to Graveyard");
		} 
		update($g);
end



rule "608.3"
//martina-damiano aggiunto controllo se la spell che si sta risolvendo ha target, se si deve essere gestita con il resolving dell'aura 
/*
MANCAVA IL TESTO AGGIUNTO QUELLO VERSIONE
	November 19, 2021
If the object that's resolving is a permanent spell, its resolution involves a single step (unless it's an Aura, a copy of a permanent spell, 
or a mutating creature spell). The spell card becomes a permanent and is put onto the battlefield under the control of the spell's 
controller.
*/ 
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == null, $id: resolvingSpell.idController,
			resolvingSpell.cardType[0].contains("artifact") || resolvingSpell.cardType[0].contains("creature") || resolvingSpell.cardType[0].contains("enchantment") || resolvingSpell.cardType[0].contains("planeswalker"),
			!resolvingSpell.subtype[0].contains("Aura"))
		$p: Player(id == $id)
	then
		$g.resolvingSpell.isPermanent = true;
		Permanent p = new Permanent($g.resolvingSpell.originCard, $g.giveMeMyId(), $id, $g.getIdBattlefieldCounter());
		if($g.resolvingSpell.getTargetted_id()!=-1){
			//p.setTarget_id($g.resolvingSpell.getTargetted_id()); RISOLUZIONE SPELL ENCHANT 
		}
		$g.battleField.add(p);
		$g.resolvingSpell = null;
		$g.resolvedSpell = true;
		System.out.println("608.3 -> The resolving spell is a Permanents: it goes on the Battlefield");
		GameEngine.sendToNode("Permanent Spell resolved goes on the Battlefield");
		update($g); 		 	
end


rule "608.3a"
//martina-damiano aggiunto controllo se la spell che si sta risolvendo ha target, se si deve essere gestita con il resolving dell'aura 
/*
November 19, 2021
608.3a
If the object that's resolving is an Aura spell, its resolution involves two steps. First, it checks whether the 
target specified by its enchant ability is still legal, as described in rule 608.2b. (See rule 702.5, "Enchant.") If so, 
the spell card becomes a permanent and is put onto the battlefield under the control of the spell's controller attached to 
the object it was targeting. 
*/
dialect "mvel"
agenda-group "general"
no-loop true 
  when
    $g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == null, 
    		$id: resolvingSpell.idController, resolvingSpell.subtype[0].contains("Aura"))
    $p: Player(id == $id)
  then
    $g.resolvingSpell.isPermanent = true;
    boolean add = false;
    Permanent pe = new Permanent($g.resolvingSpell.originCard, $g.giveMeMyId(), $id, $g.getIdBattlefieldCounter());
    for(Permanent p1 : $g.getBattleField()){
    	if($g.resolvingSpell.getTargetted_id() != -1){
    		if(p1.getMagicTargetId() == $g.resolvingSpell.getTargetted_id()){	
				pe.attached_to.add($g.resolvingSpell.getTargetted_id());
        		p1.attached_by.add(pe.getMagicTargetId());
        		p1.attby_perm.add(pe);
	     		add = true;
    		} 
	    }
	}
	if(add == true){
        $g.battleField.add(pe);
        $g.resolvingSpell = null;
		$g.resolvedSpell = true;
        GameEngine.sendToNode("608.3a - Permanent Spell resolved goes on the Battlefield");
		}
   	update($g);        
end



rule "608.3d"
/* 
November 19, 2021
608.3d
If a permanent spell resolves but its controller can't put it onto the battlefield, that player puts it into 
its owner's graveyard.
*/
dialect "mvel"
agenda-group "general"
no-loop true 
	when
		$g: Game(stage == Game.GAME_STAGE, resolvingSpell != null, resolvingSpell.isPermanent == true, $id: resolvingSpell.idController)
		$p: Player(id == $id)
	then
		 // Da implementare con le carte
end
  


rule "701.6a"
/*
November 19, 2021
701.6a 
To create one or more tokens with certain characteristics, put the specified number of tokens 
with the specified characteristics onto the battlefield.
*/
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 500

	when
		$g: Game(stage == Game.GAME_STAGE)
	then
end


rule "701.7a"
/*
November 19, 2021
701.7a
To destroy a permanent, move it from the battlefield to its owner's graveyard.
*/
	//Gestito come funzione destroy in main
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 500
	when
		$g: Game(stage == Game.GAME_STAGE)
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, index == -1)
	then
		$rpc.next()
		update($rpc)
end


rule "702.3a"
/*
	9th January 2023
	702.3a. Defender is a static ability.
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck, $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && abilityText.startsWith("Defender")) from $la
	then
		System.out.println("702.3a -> Trovata Defender");
		$a.setKeyword_ability(true);	
		$a.setStatic_ability(true);
		//$a.setDefender(true);
		//$a.setKeyword_text("defender");
		update($p)
end


rule "704.3"
/*
--- November 19, 2021 ---
704.3 
Whenever a player would get priority (see rule 117, "Timing and Priority"), 
the game checks for any of the listed conditions for state-based actions, then 
performs all applicable state-based actions simultaneously as a single event. 
If any state-based actions are performed as a result of a check, the check is 
repeated; otherwise all triggered abilities that are waiting to be put on the 
stack are put on the stack, then the check is repeated. Once no more state-based 
actions have been performed as the result of a check and no triggered abilities are 
waiting to be put on the stack, the appropriate player gets priority. This process 
also occurs during the cleanup step (see rule 514), except that if no state-based 
actions are performed as the result of the step's first check and no triggered 
abilities are waiting to be put on the stack, then no player gets priority and the step ends.
*/
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 490
	when
		$g: Game(stage == Game.GAME_STAGE, $pm: priorityMarker, $bf : battleField, controlStateBasedActions)
		$p: Player() from $pm.object
		forall ( //rule 704.5a
			Player(lifeTotal > 0) from $g.players
		)
		forall ( //rule 704.5b
			Player(!emptyLibrary) from $g.players
		)
		forall ( //rule 704.5g
			Permanent(
				(cardType[0].contains("creature") &&
				(Integer.parseInt(toughness[0]) <= 0 || Integer.parseInt(toughness[0]) > markedDamage))
				||
				(!cardType[0].contains("creature"))
			) from $bf
		)
	then
		if($p.printManaPool().length() > 0){
			GameEngine.sendToNode("player " + $p.nickname + " ha il seguente mana: " + $p.printManaPool());
		}
		if($pm.hasNext()){
			$pm.next();
		} else{
			$pm.toHead();
			$pm.next();
		}
		System.out.println("704.3 Cambio priorit� --> Player: " + $g.priorityMarker.getObject().nickname);
		GameEngine.sendToNode("- Priority Player: " +  $g.priorityMarker.getObject().nickname +" - Active Player: " + $g.activePlayer.getObject().nickname);
		$g.controlStateBasedActions = false;
		//retract($rpc)
		update($g)
end




rule "704.5a"
/*
 --- November 19, 2021 ---
If a player has 0 or less life, that player loses the game. */
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 500
	when
		$g: Game(stage == Game.GAME_STAGE, $ap: activePlayer, $pm: priorityMarker, controlStateBasedActions)
		$a: Action(option == Game.PASS_PRIORITY)
		$p: Player(lifeTotal <= 0) from $g.players
	then
		GameEngine.sendToNode("704.5a --> The player " + $p.nickname + " lost the game because has 0 or less life.");
		System.out.println("704.5a --> The player " + $p.nickname + " lost the game because has 0 or less life.");
		$ap.remove($p);
		$pm.remove($p);
		$p.hasWin = Player.PLAYER_LOOSE;
		update($g)
end


rule "704.5b"
/*
November 19, 2021
If a player attempted to draw a card from a library with no cards in it since the last time state-based actions were checked, that player loses the game.
*/
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 500
	when
		$g: Game(stage == Game.GAME_STAGE, $ap: activePlayer, $pm: priorityMarker, controlStateBasedActions)		
		$a: Action(option == Game.PASS_PRIORITY)
		$p: Player(emptyLibrary) from $g.players
	then
		GameEngine.sendToNode("704.5b --> The player " + $p.nickname + " lost the game because his or her library is empty.");
		System.out.println("704.5b --> The player " + $p.nickname + " lost the game because his or her library is empty.");
		$ap.remove($p);
		$pm.remove($p);
		$p.hasWin = Player.PLAYER_LOOSE;	
		update($g)		
end

rule "704.5c"
	/* 
		November 19, 2021
		If a player has ten or more poison counters, that player loses the game. Ignore this rule in Two-Headed Giant games; see rule 704.6b instead. */
	dialect "mvel"
	agenda-group "general"
	no-loop true
	salience 500
	
	when
		$g: Game(stage == Game.GAME_STAGE, $ap: activePlayer, $pm: priorityMarker)
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5c")
	then
		System.out.println("704.5c --> Controlling if a players has lost the game due to his/her poison counters");
		
		for (Player p : $ap.listReference) {
			if (p.poisonCounter >= 10) {
				GameEngine.sendToNode("704.5c --> The player " + p.nickname + " has lost the game because he or she has " + p.poisonCounter + " poison counters.");
				System.out.println("704.5c --> The player " + p.nickname + " has lost the game because he or she has " + p.poisonCounter + " poison counters.");
				
				$ap.remove(p);
				$pm.remove(p);
				p.hasWin = Player.PLAYER_LOOSE;
			}
		}
		
		$rpc.removeAndGoToNext();
		update($rpc)
end



rule "704.5d"
/*
	November 19, 2021
	If a token is in a zone other than the battlefield, it ceases to exist.
*/
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end


rule "704.5e"
/*
November 19, 2021
If a copy of a spell is in a zone other than the stack, it ceases to exist. 
If a copy of a card is in any zone other than the stack or the battlefield, 
it ceases to exist.
*/

	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end


rule "704.5f"	//non trigghera :+1
/*
November 19, 2021
704.5f. If a creature has toughness 0 or less, it's put into its owner's graveyard.
Regeneration can't replace this event.
*/
	dialect "mvel"
	agenda-group "general"
	salience 500
	no-loop true
	
	when
		$g:Game(stage == Game.GAME_STAGE, $bf : battleField)
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5f")
	then
		System.out.println("704.5f --> Controlling if there are creature that have toughness lower or equal than zero.");	
		for (Permanent p : $bf) {
			if(p.deathtouched){
				System.out.println(p.getNameAsString + " ha Deathtouch !");
				System.out.println(p.getNameAsString + " viene distrutta");
				$g.destroy(p);
			} 
			else if (p.cardType[0].contains("creature") && Integer.parseInt(p.toughness[0]) <= 0) {
				System.out.println(p.getNameAsString + " ha toughness minore di 0");
				System.out.println(p.getNameAsString + " viene distrutta");
				$g.destroy(p);
			}
		}
		
		$rpc.removeAndGoToNext();		
		update($rpc)
		update($g)
end



rule "704.5g"
/*
November 19, 2021
704.5g. If a creature has toughness greater than 0, and the total damage marked on 
it is greater than or equal to its toughness, that creature has been dealt lethal damage 
and is destroyed. Regeneration can replace this event.
*/
	dialect "mvel"
	agenda-group "general"
	salience 500
	when		
		$g: Game(stage == Game.GAME_STAGE, $bf : battleField, $ap: activePlayer, $pm: priorityMarker, controlStateBasedActions)
		$a: Action(option == Game.PASS_PRIORITY)
		$pmt: Permanent(
				cardType[0].contains("creature"),
				Integer.parseInt(toughness[0]) > 0,
				Integer.parseInt(toughness[0]) <= markedDamage
			) from $bf
	then
		System.out.println("704.5g --> Controlling if there are creature that have marked damage greater or equal than toughness.");
		System.out.println($pmt.getNameAsString+" ha toughness "+Integer.parseInt($pmt.toughness[0])+" e danni "+$pmt.markedDamage);
		System.out.println($pmt.getNameAsString+" viene distrutta");
		$g.destroy($pmt);
		update($g)
		System.out.println("----------- TEST 704.5g -----------");
end

rule "704.5h"
	/* November 19, 2021
	   If a creature has toughness greater than 0, and it's been dealt damage by a source with 
	   deathtouch since the last time state-based actions were checked, that creature is destroyed.
	   Regeneration can replace this event. */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.5i"
	/*
	--- November 19, 2021 ---
	704.5i. If a planeswalker has loyalty 0, it's put into its owner's graveyard.
*/
	dialect "mvel"
	agenda-group "general"
	salience 500
	
	when
		$g:Game(stage == Game.GAME_STAGE, $bf : battleField)
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5i")
	then
		System.out.println("704.5i --> Controlling if there are planeswalkers in the battlefield that have loyalty lower or equal than zero.");
		for (Permanent p : $bf) {
			if (p.cardType[0].contains("planeswalker") && Integer.parseInt(p.loyalty[0]) <= 0) {
				System.out.println(p.getNameAsString+" ha loyalty uguale a 0");
				System.out.println(p.getNameAsString+" viene distrutta");
				$g.destroy(p);
			}
		}
		
		$rpc.removeAndGoToNext();
		update($rpc)
		update($g)
end

rule "704.5j"
	/* OBSOLETA
	   If a player controls two or more planeswalkers that share a planeswalker type, 
	   that player chooses one of them, and the rest are put into their owners' graveyards. 
	   This is called the "planeswalker uniqueness rule." */
	/*
	November 19, 2021
	 If a player controls two or more legendary permanents with the same name, that player chooses one of them, and the rest are put into their owners' graveyards. 
	 This is called the "legend rule."
	*/
	dialect "mvel"
	agenda-group "general"
	salience 500
	
	when
		$g: Game(stage == Game.GAME_STAGE, $szfPm: sevenzerofourPlayerMarker, $szfPm.size > 0, playerHasToMakeChoiceszf == false)
		$pl: Player() from $szfPm.object
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5j")
		
	then
		System.out.println("704.5j --> Controlling " + $pl.nickname + " if has planeswalker in the battlefield that share the same type.");
		LinkedList planeswalkers = new LinkedList();
		for(MagicObject mo : $g.battleField){
			Permanent p = (Permanent) mo;
			if (p.idController == $pl.id &&
				p.cardType[0].contains("planeswalker")) {
				planeswalkers.add(p);
			}
		}
		
		if (planeswalkers.size() <= 1) {
			$szfPm.removeAndGoToNext();
		} else {
			MakeChoice choice = new MakeChoice();
			choice.idChoice = 70451;
			choice.choiceText ="Choose which planeswalker you would maintain:";
			for(Permanent controlledPlaneswalker : planeswalkers){
				boolean found = false;
				for(Permanent currentPlaneswalker : planeswalkers){
					for(String subtype : currentPlaneswalker.subtype[0]){
						if (controlledPlaneswalker.subtype[0].contains(subtype)) {
							found = true;
						}
					}
				}
				choice.addOption(controlledPlaneswalker.magicTargetId, controlledPlaneswalker.nameAsString);
			}
			
			if (choice.choiceOptions.size <= 1) {
				$szfPm.removeAndGoToNext();
			} else {
				GameEngine.sendToNode(choice, Game.CHOICE, Game.ONE_OF_CHOICE, $pl.id);
				$g.playerHasToMakeChoiceszf = true;
			}
		}	
		
		update($g)
end

rule "704.5j answerHandler"
	dialect "mvel"
	agenda-group "general"
	salience 500
	
	when
		$g: Game(stage == Game.GAME_STAGE, $szfPm: sevenzerofourPlayerMarker, playerHasToMakeChoiceszf == true)
		$pl: Player() from $szfPm.object
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5j")
		$ca: ChoiceAnswer(idChoice == 70451, idPlayer == $pl.id)
	then
		System.out.println("704.5j answerHandler --> Handle the response from " + $pl.nickname); 
		// Retrieves the selected planeswalker subtypes
		LinkedList subtypes = new LinkedList();
		for(Permanent p : $g.battleField) {
			if (p.idController == $pl.id && 
				p.magicTargetId == $ca.idOptions.get(0)) {
				subtypes.addAll(p.subtype[0]);
			}
		}
		
		// Checks if a permanent is a planeswalker that
		// share anyone of the subtypes with that the player
		// has selected
		for(Permanent p : $g.battleField){
			if (p.idController == $pl.id && 
				p.cardType[0].contains("planeswalker") && 
				p.magicTargetId != $ca.idOptions.get(0)) {
				for(String subtype : subtypes) {
					if (p.subtype[0].contains(subtype)) {
						System.out.println("704.5j answerHandler --> Destroying " + p.nameAsString + " of the player " + $pl.nickname);
						$g.destroy(p);
					}
				}
			}
		}
		
		$g.playerHasToMakeChoiceszf = false;
		$szfPm.removeAndGoToNext();
		retract($ca)
		update($g)
end

rule "704.5j end"
	dialect "mvel"
	agenda-group "general"
	salience 500
	
	when
		$g: Game(stage == Game.GAME_STAGE, $szfPm: sevenzerofourPlayerMarker, $szfPm.size == 0, playerHasToMakeChoiceszf == false)
		$rpc: RulePriorityCounter(scope == RulePriorityCounter.STATE_BASED_ACTIONS, $rpc.getObject() == "704.5j")
	then
		System.out.println("704.5j end --> Passando alla regola successiva");
		$rpc.removeAndGoToNext();
		update($rpc)
		update($g)
end

rule "704.5k"
	/*
	--- November 19, 2021 ---
	If two or more permanents have the supertype world, all except the one that has had the world supertype for the shortest amount of time are put into their owners' graveyards. In the event of a tie for the shortest amount of time, all are put into their owners' graveyards. 
	This is called the "world rule."
	*/
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
end


rule "704.5m"
/* 
--- November 19, 2021 ---
If an Aura is attached to an illegal object or player, or is not attached to an object or player, 
that Aura is put into its owner's graveyard. 
*/
	dialect "mvel"
	agenda-group "general"
	when
		$g: Game(stage == Game.GAME_STAGE, $b: battleField)
		$p: Permanent(attached_to != null, cardType[0].contains("enchantment") && subtype[0].contains("Aura")) from $b
		// Per ogni permanent che abbia degli id in lista di attach e che sia un Enchantment - Aura
	then
		int count = 0;
		// Scorri tutti i permanent sul battlefield
		System.out.println("704.5m");
		for(Permanent perm : $b){
			if(perm.magicTargetId == $p.attached_to[0]){
				count += 1;		
			}
		}
		
		if(count == 0){
			$p.attached_to = null;			// metti a null la lista di attach
			$g.destroy($p);					// distruggi il permanent che era sul battlefield
		}
		
end


rule "704.5n"
/*
704.5n
If an Equipment or Fortification is attached to an illegal permanent, it becomes unattached from that permanent. 
It remains on the battlefield.
*/
/*
	November 19, 2021
If an Aura is attached to an illegal object or player, or is not attached to an object or player,
that Aura is put into its owner's graveyard.
*/
	dialect "mvel"
	agenda-group "general"	
	when
		$g: Game(stage == Game.GAME_STAGE, $b: battleField)
		$p: Permanent(attached_to != null && attached_to.size() > 0, cardType[0].contains("artifact")) from $b
		// Per ogni permanent che abbia degli id in lista di attach e che sia un artifact
	then
		int count = 0;
		// Scorri tutti i permanent sul battlefield
		for(Permanent attached : $b){
			//Se ne trovi uno che abbia un id nella lista di attached_to aggiungi uno a count 
			if(attached.getMagicTargetId() == $p.attached_to[0]){
				count = count + 1;
			} 
		}
		if(count == 0){
			// Finito di contare, se sei ancora a 0 significa che non hai trovato il permanent che avevi attachato
			$p.attached_to = null; // In questo caso basta settare attached to a null
		}	
end


rule "113.3c"
/*
November 19, 2021
113.3c NUOVO NUMERO
Triggered abilities have a trigger condition and an effect. 
They are written as "[Trigger condition], [effect]," and include (and usually begin with) the word "when," "whenever," or "at." Whenever the trigger event occurs, the ability is put on the stack the next time a player would receive priority and stays there until it's countered, it resolves, or it otherwise leaves the stack. 
See rule 603, "Handling Triggered Abilities."
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(
				abilityText.matches("(when |whenever |at )(.+)(,)(.+)")
				&& triggered_ability==false
			) from $la
	then	
		$a.setTriggered_ability(true);
		System.out.println("Trovata Triggered Ability: "+$a.getAbilityText());
		update($p)
end

//martina-damiano cerco nel testo ":" per riconoscere le activated ability, setto il booleano

rule "113.3b"
/*
November 19, 2021
113.3b NUOVO NUMERO
Activated abilities have a cost and an effect. They are written as "[Cost]: [Effect.] [Activation instructions (if any).]" A player may activate such an ability whenever they have priority. Doing so puts it on the stack, where it remains until it's countered, it resolves, or it otherwise leaves the stack. 
See rule 602, "Activating Activated Abilities."
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(
			(abilityText.contains(":")) && activated_ability==false
			) from $la
	then	
		$a.setActivated_ability(true);
		System.out.println("Trovata Activated Ability: "+$a.getAbilityText());
		update($p)
end

/*112.3d Static abilities are written as statements. They're simply true. 
Static abilities create continuous effects which are active while the permanent with the ability is on 
the battlefield and has the ability, or while the object with the ability is in the appropriate zone.
Se abilità non è ne triggered ne activated ne spell allora è statica

November 19, 2021
113.3b NUOVO NUMERO
Static abilities are written as statements. 
They're simply true. Static abilities create continuous effects which are active while the permanent with the ability is on the battlefield and has the ability, or while the object with the ability is in the appropriate zone. 
See rule 604, "Handling Static Abilities."

TODO: le spell vengono settate quando viene creata ability on the stack a questo punto questa regola deve sparare
dopo! cosi anche le spell ora sono settate a statiche
rule "113.3b"
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability( triggered_ability == false && static_ability == false &&
					  activated_ability==false && spell_ability==false) from $la
	then	
		$a.setStatic_ability(true);
		System.out.println("Trovata Static Ability: "+$a.getAbilityText());
		update($p)
end*/


/*		if(abilityText.contains("target creature"))
			$a.setTargetType("creature");
		else if(abilityText.contains("target land"))
			$a.setTargetType("land");
		else if(abilityText.contains("target planeswalker"))
			$a.setTargetType("planeswalker");
*/

//martina-damiano cerco le abilità che hanno target e setto il booleano, inoltre riconosco il tipo di target/i tipi di target se multipli tra artefatti, creature, giocatore, terre,
//spell, opponent, permanenti, equipment, blu, verde, rosso, nero, bianco e beast.
rule "115.1a"
/*
--- November 19, 2021 ---
	115.1a NUOVO NUMERO
1a An instant or sorcery spell is targeted if its spell ability identifies something it will affect by  using the phrase "target [something]," where the "something" 
is a phrase that describes an object, player, or zone. The target(s) are chosen as the spell is cast; see rule 601.2c. (If an activated or triggered ability of an instant 
or sorcery uses the word target, that ability is targeted, but the spell is not.)*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(targetted_ability == false && (abilityText.contains("target ") == true 
			|| abilityText.contains("targets ") == true)) from $la
	then	
		$a.setTargetted_ability(true);
		$a.setManaCostSymbols();
		String[] words = $a.getAbilityText().split(" ");
		int i=0;
		int j=0;
		boolean trovato=false;
		for(i = 0; i < words.length-1; i++){
			if(words[i].equals("target") || words[i].equals("targets")){
				if(
					words[i+1].equals("artifact") ||
					words[i+1].equals("creature") ||
					words[i+1].equals("player") ||
					words[i+1].equals("land") ||
					words[i+1].equals("spell") ||
					words[i+1].equals("opponent") ||
					words[i+1].equals("opponent's") ||
					words[i+1].equals("permanent") ||
					words[i+1].equals("Equipment") ||
					words[i+1].equals("blue") ||
					words[i+1].equals("green") ||
					words[i+1].equals("red") ||
					words[i+1].equals("black") ||
					words[i+1].equals("white") ||
					words[i+1].equals("Beast") 
				)
					$a.addTargetType(words[i+1]); // non ho messo check sull'esistenza di i+1 in quanto il for termina 1 passo prima
				j = i + 3;
				if(j < words.length){
					if(words[j-1].equals("or")){
						if(
							words[j].equals("artifact") ||
							words[j].equals("creature") ||
							words[j].equals("player") ||
							words[j].equals("land") ||
							words[j].equals("spell") ||
							words[j].equals("opponent") ||
							words[j].equals("opponent's") ||
							words[j].equals("permanent") ||
							words[j].equals("Equipment") ||
							words[j].equals("blue") ||
							words[j].equals("green") ||
							words[j].equals("red") ||
							words[j].equals("black") ||
							words[j].equals("white") ||
							words[j].equals("Beast") 
						)
						$a.addTargetType(words[j]);
					}
				}
			}					
		}		
		System.out.println("Trovata Targetted Ability "+ $a.getAbilityText() + "| Type: " +$a.getTargetType().toString()+" cardID:"+$c.getId());
		update($p)
end
// cercare solo i tipi, la regola va estesa con i target di magiccard info


//martina-damiano cerco nella stringa il testo "to your mana pool", setto il booleano delle mana ability
rule "605.1a"
/*605.1 MANA ABILITY
--- November 19, 2021 ---
1a. activated ability: it doesn't have a target, it could add mana to a player's mana pool when it resolves, and it's not a loyalty ability 
1b. triggered ability: it doesn't have a target, it triggers from the resolution of an activated mana ability or from mana being added to a player's mana pool, 
and it could add mana to a player's mana pool when it resolves.*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE);
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib;
		$la: LinkedList() from $c.getAbilities();
		$a : Ability(
			mana_ability==false && 
			targetted_ability==false &&
			abilityText.contains("dd {") &&
			(
				(loyalty_ability == false && activated_ability==true) || 
				(triggered_ability==true)
			)
		) from $la
	then	
		$a.setMana_ability(true);
		System.out.println("Trovata Mana Ability: "+$a.getAbilityText());
		update($p)
end
//controllare la stringa add to your mana pool


//Galt & Carlo
//le terre base non riportano piu' il testo dell'abilita' di mana
//questa regola aggiunge il testo dell'abilita di mana alle terre base
rule "605.1a extended for Lands"
/*
--- November 19, 2021 ---
605.1 MANA ABILITY - Extended*/
no-loop true
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE);
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib;
		$lspt: LinkedList() from $c.getSupertype(); //list of supertypes
		$spt : String(
			this=="basic"
		) from $lspt;
		$lt: LinkedList() from $c.getCardType(); //list of types
		$t : String(
			this=="land"
		) from $lt;
		$lsbt: LinkedList() from $c.getSubtype(); //list of subtypes
		$sbt : String() from $lsbt;
		$la: LinkedList() from $c.getAbilities(); //list of abilities
		$a : Ability(
			mana_ability==false
		) from $la
	then
		switch($sbt) { //inserisce il testo d'abilita' a seconda del tipo di terra ({T}: Add [mana symbol])
			case "Plains":
				$a.setAbilityText("{T}: Add {W}");
				break;
			case "Island":
				$a.setAbilityText("{T}: Add {U}");
				break;
			case "Swamp":
				$a.setAbilityText("{T}: Add {B}");
				break;
			case "Mountain":
				$a.setAbilityText("{T}: Add {R}");
				break;
			case "Forest":
				$a.setAbilityText("{T}: Add {G}");
				break;
		}
		$a.setMana_ability(true);
		System.out.println("Inserita Mana Ability su terra base: "+$a.getAbilityText());
		update($p)
end


rule "702.2a"
/**
	Deathtouch is a static ability.
	
	@date 2022/2023
	@author Cristian Cosci, Fabrizio Fagiolo, Nicolò Vescera
**/
agenda-group "general"
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && static_ability==false && 
			abilityText.toLowerCase().startsWith("deathtouch")) from $la
	then
		$a.setStatic_ability(true);
		System.out.println("702.2a -> Trovato Deathtouch: " + $c.getName());
		
		update($p)
end
	
	
rule "702.2b"
/**
	A creature with toughness greater than 0 that s been dealt damage by a source with deathtouch since the 
	last time state-based actions were checked is destroyed as a state-based action. 
	See rule 704.
	
	@date 2022/2023
	@author Cristian Cosci, Fabrizio Fagiolo, Nicolò Vescera
**/
dialect "mvel"
salience 500
no-loop true 
agenda-group "general"
when
	$g: Game(
			stage == Game.GAME_STAGE, 
			$bf : battleField,
			$attaccanti: attackingCreatures.listReference,
			$bloccanti: blockingCreatures.listReference,
			controlStateBasedActions
		)
	
	// contiene tutte le carte in combattimento (bloccanti e attaccanti)
   	$allCardsInCombact: (Permanent() from $attaccanti or Permanent() from $bloccanti)
    $pmt: Permanent (
				cardType[0].contains("creature"),
				deathtouched == true
			) from $allCardsInCombact
		
	then
		System.out.println("702.2b --> Morte per Deathtouch.");
		System.out.println("\t" + $pmt.getNameAsString+" subisce Deathtouch !");
		System.out.println("\t" + $pmt.getNameAsString+" viene distrutta");
		
		GameEngine.sendToNode("La carta " + $pmt.getNameAsString + " viene distrutta per Deathtouch!");
			
		$g.destroy($pmt);

		update($g)
end


rule "702.2c"
/**
	Any nonzero amount of combat damage assigned to a creature by a source with deathtouch is considered to 
	be lethal damage for the purposes of determining if a proposed combat damage assignment is valid, 
	regardless of that creature s toughness. 
	See rules 510.1c-d.
	
	@date 2022/2023
	@author Cristian Cosci, Fabrizio Fagiolo, Nicolò Vescera
**/
dialect "mvel"
salience 600
no-loop true 
agenda-group "general"
	when
		$g:Game(
			stage == Game.GAME_STAGE, 
			stepTimeFrame == Game.BEGIN_TIME_FRAME, 
			$bf: battleField, 
			$blk: blockingCreatures, 
			$atk: attackingCreatures
			)
		eval($g.currentStep.getObject().name == "combat damage")
		eval($g.stepCombatDamage.getObject() == "510.2")
		
		// contiene tutte le carte in combattimento (bloccanti e attaccanti)
		$allCardsInCombact: ( Permanent() from $atk.listReference or Permanent() from $blk.listReference)
		$pmt: Permanent(
				$difensori: blockedCreatures.listReference,
				$attaccanti: blockedBy.listReference,
				cardType[0].contains("creature"),
				Integer.parseInt(toughness[0]) > 0,
				combatDamage > 0,
				//markedDamage > 0,
				//damageDealt > 0,
				deathtouched == false
			) from $allCardsInCombact
		
		exists ( 
			Permanent(cardType[0].contains("creature") && checkKeywordAbility("Deathtouch")) from $difensori or 
			Permanent(cardType[0].contains("creature") && checkKeywordAbility("Deathtouch")) from $attaccanti
		)
			
	then
		System.out.println("702.2c --> Marchiamento Deathtouch.");
		System.out.println("\t" + $pmt.getNameAsString+" viene marchiata con Deathtouch !");
		
		$pmt.setDeathtouched(true);

		update($g)
end

rule "702.4a"
/**
	@date 2022/2023
	@author Tommaso Romani, Nicol� Posta
**/
/*Double Strike is a static ability.*/
agenda-group "general"
//no-loop true
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && static_ability==false && 
			abilityText.toLowerCase().contains("double strike")) from $la
	then
		$a.setStatic_ability(true);
		$a.setKeyword_ability(true);
		$a.setKeyword_text("double strike");
		System.out.println("702.4a -> Trovato Double Strike: " + $c.getName());
		update($p)
end


//martina-damiano cerco keyword ability equip tra le abilità attivate e setto il booleano 
rule "702.6a"
/*
November 19, 2021
 Equip is an activated ability of Equipment cards. "Equip [cost]" means "[Cost]: Attach this permanent to target creature you control. Activate only as a sorcery."*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && activated_ability==true && 
			abilityText.startsWith("Equip ")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setAs_a_sorcery(true);
		$a.setTargetted_ability(true);
		$a.setKeyword_text("Equip");
		System.out.println("Trovata Equip: "+$a.getAbilityText());
		update($p)
end
//è as a sorcery e targetted



rule "702.7a"
/**
	@date 2022/2023
	@author Tommaso Romani, Nicol� Posta
**/
/*First Strike is a static ability.*/
agenda-group "general"
//no-loop true
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && static_ability==false && 
			abilityText.toLowerCase().contains("first strike")) from $la
	then
		$a.setStatic_ability(true);
		$a.setKeyword_ability(true);
		$a.setKeyword_text("first strike");
		System.out.println("702.7a -> Trovato First Strike: " + $c.getName());
		update($p)
end



rule "702.9a"
/*
	November 19, 2021
 	Flying is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("flying")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Flying");
		update($p)
end

rule "702.9b"
/*
	November 19, 2021
 	A creature with flying can't be blocked except by creatures with flying and/or reach. 
 	A creature with flying can block a creature with or without flying. 
 	(See rule 509, "Declare Blockers Step," and rule 702.17, "Reach.")
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.9b")
	then
		System.out.println("Flying");
		
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... se ha NON Flying o Reach tra le evasion ability ...
			if (! (blocker.checkKeywordAbility("flying") || 
			       blocker.checkKeywordAbility("reach")) ) {
				// ... controllo le creature che blocca ...
				for (Permanent attacker : blocker.blockedCreatures.listReference) {
					// ... se almeno 1 attaccante ha flying ...
					if (attacker.checkKeywordAbility("flying")){
						// ... il blocco non è valido
						System.out.println("Flying: Blocco non valido!");
						$g.blockValid = false;
					}
				}
			}
		}
		$sce.next();
		update($g)
end

rule "702.10a"
agenda-group "general"	
dialect "mvel"
	when 
		$g:  Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && static_ability == false && abilityText.startsWith("haste")) from $la
		
		then
			$a.setStatic_ability(true);
			System.out.println("Trovato Haste");
			update($p)
end


rule "702.10b"
agenda-group "general"	
no-loop true
dialect "mvel"
	when 
		$g: Game( 
				stage == Game.GAME_STAGE,
				$bf: battleField
			)
		$pmt: Permanent(
				cardType[0].contains("creature"),
				summoningSickness,
				checkKeywordAbility("haste")
				) from $bf
		then 
			$pmt.summoningSickness=false;
			System.out.println("Trovata creatura con haste nel battelfied");
			
			update($g)
end


rule "702.13.a"
/*
	November 19, 2021
 	Intimidate is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("intimidate")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Intimidate");
		update($p)
end

rule "702.13b"
/*
	November 19, 2021
 	A creature with intimidate can't be blocked except by artifact creatures and/or creatures that share a color with it.
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.13b")
	then
	
		boolean shareColor = false; //controllo se bloccante e attaccanti hanno almeno un colore in comune
		boolean typeArtifactCreature = false;
		// Per ogni bloccante ...
		
		System.out.println("Intimidate b parte 1");
		for (Permanent blocker : $blockers) {
			// ...se è di tipo artefatto o/e ha un colore che condivide con il bloccante
	        // ... controllo le creature che blocca ...
				for (Permanent attacker : blocker.blockedCreatures.listReference) {
					// ... se almeno 1 attaccante ha shadow ...
					
					for(String coloreAttaccante: attacker.getColorIndicator()[0]){
					
                        //LinkedList<String> coloriBloccante = blocker.getColorIndicator().listReference;
                        
                        if( blocker.getColorIndicator()[0].contains(coloreAttaccante) ){
							shareColor = true;
						}
						
                    }                  
                    
                    System.out.println(shareColor);
                    System.out.println(blocker.getColorIndicator()[0]);
                    
                  	//controllo le creature artefatto
					//if(blocker.cardType[0].contains("artifact") && blocker.cardType[0].contains("creature")){
					//if(blocker.cardType[0].contains("artifact creature")){
					if(blocker.cardType[0].contains("creature") && blocker.cardType[0].contains("artifact")){
					         typeArtifactCreature = true;
					}
					
					if (attacker.checkKeywordAbility("intimidate") && !(shareColor == true || typeArtifactCreature == true) ){
						// ... il blocco non è valido
						System.out.println("Blocco non valido!");
						$g.blockValid = false;
					}
				}
		}
		$sce.next();
		update($g)
end


rule "702.14b"
/*
	November 19, 2021
 	 
 	Landwalk is an evasion ability
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.contains("walk")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		
		if($a.getKeyword_text().trim().equals("plainswalk")) {
			System.out.println("Trovata Plainswalk");
		}
		else if($a.getKeyword_text().trim().equals("mountainwalk")) {
			System.out.println("Trovata Mountainwalk");
		}
		else if($a.getKeyword_text().trim().equals("swampwalk")) {
			System.out.println("Trovata Swampwalk");
		}
		else if($a.getKeyword_text().trim().equals("islandwalk")) {
			System.out.println("Trovata Islandwalk");
		}
		else if($a.getKeyword_text().trim().equals("forestwalk")) {
			System.out.println("Trovata Forestwalk");
		}
		update($p)
end

rule "702.14c"
 /*
 November 19, 2021
 A creature with landwalk can't be blocked as long as the defending player controls at least one land with the specified land type (as in "islandwalk"), 
 with the specified type or supertype (as in "artifact landwalk"), without the specified type or supertype (as in "nonbasic landwalk"), or with both the 
 specified type or supertype and the specified subtype (as in "snow swampwalk"). (See rule 509, "Declare Blockers Step.")
 */
dialect "mvel"
no-loop true
agenda-group "general"
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,  
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference,
			    $defender : defendingPlayers)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.14c")
		$p: Player($id : id) from $defender.object

	then
		System.out.println("Check Landwalk...");
		String landwalk = "";
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... controllo le creature che blocca ...
			for (Permanent attacker : blocker.blockedCreatures.listReference) {
				// ... se almeno un attaccante ha una abilità "landwalk" ...
				if(attacker.checkKeywordAbility("islandwalk")){
					landwalk= "Island";
				}
				else if(attacker.checkKeywordAbility("mountainwalk")){
					landwalk= "Mountain";
				}
				else if(attacker.checkKeywordAbility("swampwalk")){
					landwalk= "Swamp";
				}
				else if(attacker.checkKeywordAbility("plainswalk")){
					landwalk= "Plains";
				}
				else if(attacker.checkKeywordAbility("forestwalk")){
					landwalk= "Forest";
				}
				//...controllo tutte le carte in campo...
				for(Permanent perm : $g.battleField) {
					//...se ci sono terre di tipo "landwalk" controllate dal difensore
					if((perm.cardType.size() > 0 && perm.cardType[0].contains("land")) && (perm.getIdController == $id) && (perm.subtype[0].contains(landwalk))) {
						// ... il blocco non è valido.
						System.out.println("Blocco non valido!");
						$g.blockValid = false;
					}
				}
			}
		}
		$sce.next();
		update($g)
end



rule "702.28a"
/*
	November 19, 2021
 	Shadow is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("shadow")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Shadow");
		update($p)
end

rule "702.28b part 1"
/*
	November 19, 2021
 	A creature with shadow can't be blocked by creatures without shadow
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.28b part 1")
	then
		System.out.println("Shadow parte 1");
		
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... se ha NON Shadow tra le evasion ability ...
			if (! blocker.checkKeywordAbility("shadow")) {
				// ... controllo le creature che blocca ...
				for (Permanent attacker : blocker.blockedCreatures.listReference) {
					// ... se almeno 1 attaccante ha shadow ...
					if (attacker.checkKeywordAbility("shadow")){
						// ... il blocco non è valido
						System.out.println("Blocco non valido!");
						$g.blockValid = false;
					}
				}
			}
		}
		$sce.next();
		update($g)
end

rule "702.28b part 2"
/*
	November 19, 2021
 	A creature without shadow can't be blocked by creatures with shadow. 
 	(See rule 509, "Declare Blockers Step.")
 	
 	== Una creatura con shadow non può bloccare una creatura senza shadow
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.28b part 2")
	then
		//System.out.println("Shadow parte 2");
		// bloccanti con shadow
		LinkedList blockersWithShadow = new LinkedList();
		for (Permanent blocker : $blockers) {
			if (blocker.checkKeywordAbility("shadow")){
				blockersWithShadow.add(blocker);
			}
		}
		
		// attaccanti senza shadow
		LinkedList attackersWithoutShadow = new LinkedList();
		for (Permanent attacker : $attackers) {
			if (! attacker.checkKeywordAbility("shadow")) {
				attackersWithoutShadow.add(attacker);
			}
		}
		
		// per ogni bloccante con shadow ...
		for (Permanent blocker : blockersWithShadow){
			// ... rimuovo dalla lista degli attaccanti che possono essere bloccati tutti quelli senza shadow
			blocker.attackersICanBlock.removeAll(attackersWithoutShadow);
			System.out.println(blocker.idBattlefield + " can block " + blocker.attackersICanBlock);
		}
		$sce.next();
		update($g)
end




///////////////////////////////
//////////////////////////////
/////////////////////////////

rule "702.31a"
/*
	November 19, 2021
 	Horsemanship is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("horsemanship")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Horsemanship");
		update($p)
end


rule "702.31b"
/*
	November 19, 2021
    A creature with horsemanship can't be blocked by creatures without horsemanship. 
    A creature with horsemanship can block a creature with or without horsemanship.

    se il bloccate ha horsemanship pu� bloccare creature con o senza horsemanship
    un attaccante con horsemanship non pu� essere bloccato da creature senza horsemanship
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.31b")
	then
		System.out.println("Horsemanship");
		
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... se ha NON Shadow tra le evasion ability ...
			if (! blocker.checkKeywordAbility("horsemanship")) {
				// ... controllo le creature che blocca ...
				for (Permanent attacker : blocker.blockedCreatures.listReference) {
					// ... se almeno 1 attaccante ha shadow ...
					if (attacker.checkKeywordAbility("horsemanship")){
						// ... il blocco non � valido
						System.out.println("Blocco non valido!");
						$g.blockValid = false;
					}
				}
			}
		}
		$sce.next();
		update($g)
end

rule "702.36a"
/*
	November 19, 2021
 	Fear is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("fear")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Fear");
		update($p)
end

rule "702.36b"
/*
	November 19, 2021
 	A creature with fear can't be blocked by creatures artefact or black creatures 
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.36b")
	then
		System.out.println("Fear");
		
		boolean colorBlack = false;
		boolean typeArtifactCreatureFear = false;
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... se non � di tipo artefatto o non � di colore nero...
			//if (! blocker.getCardType().toString() == "artifact creature" or ! blocker.getColorIndicator("black")) 
				// ... controllo le creature che blocca ...
				for (Permanent attacker : blocker.blockedCreatures.listReference) {
					//controllo i bloccanti con il colore nero
				    //List<String> blockBlack : blocker.getColorIndicator()[0].listReference;
					if(blocker.colorIndicator[0].contains("black")){
					         colorBlack = true;
					}
					//controllo le creature artefatto
					//if(blocker.cardType[0].contains("artifact creature")){
					if(blocker.cardType[0].contains("creature") && blocker.cardType[0].contains("artifact")){
					         typeArtifactCreatureFear = true;
					}
					//for(Permanent typeCreature: blocker.getCardType()){
                    	//if(typeCreature.toString() == "artifact creature"){
                    		//typeArtifactCreatureFear = true;
                    	//}
                    //}
                    
					if ((colorBlack == false && typeArtifactCreatureFear == false) && attacker.checkKeywordAbility("fear")){
						// ... il blocco non è valido
						System.out.println("Blocco non valido!");
						$g.blockValid = false;
					}
					     
				}
	    }
		
		$sce.next();
		update($g)
end


rule "702.111a"
/*
	November 19, 2021
 	Menace is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("menace")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Menace");
		update($p)
	end


rule "702.111b"
/*	
	November 19, 2021
	A creature with menace can't be blocked except by two or more creatures. 
	(See rule 509, "Declare Blockers Step.")
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.111b")
	then
		System.out.println("Menace");
		
		// Per ogni attaccante ...
		for (Permanent attacker : $attackers) {
			// ... se ha Menace tra le evasion ability ...
			if (attacker.checkKeywordAbility("menace")) {
				// ... conto le creature che lo bloccano ...
				int numero_bloccanti = 0;
				for (Permanent blocker : $blockers) {
					if(blocker.blockedCreatures.listReference.contains(attacker)) {
						numero_bloccanti ++;
					}
				}
				// ... se l'attaccante con Menace ha un solo bloccante ...
				if (numero_bloccanti == 1) {
					// ... il blocco non è valido
					System.out.println("Menace: Blocco non valido!");
					$g.blockValid = false;
				}
			}
		}
		$sce.next();
		update($g)
end


rule "702.118a"
/*
	November 19, 2021
 	Skulk is an evasion ability.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getKeywordAbilities()
		$a : Ability(keyword_ability==false && keyword_text.equals("skulk")) from $la
	then	
		$a.setKeyword_ability(true);
		$a.setEvasion_ability(true);
		System.out.println("Trovata Skulk");
		update($p)
end

rule "702.118b"
/*
	November 19, 2021
 	A creature with skulk can't be blocked by creatures with greater power. 
 	(See rule 509, "Declare Blockers Step.")
*/
dialect "mvel"
no-loop true
agenda-group "general"	
	when
		$g:Game(stage == Game.GAME_STAGE,
				stepCheckEvasionAbility.listReference.size() > 0,
				$sce: stepCheckEvasionAbility,
				$blockers: blockingCreatures.listReference,
				$attackers: attackingCreatures.listReference)
		eval($g.currentStep.getObject().name == "declare blockers")
		eval($g.stepCheckEvasionAbility.getObject() == "702.118b")
	then
		System.out.println("Skulk");
		
		// Per ogni bloccante ...
		for (Permanent blocker : $blockers) {
			// ... ottengo il suo valore di attacco, poi ...
			b_power = Integer.parseInt(blocker.power[0]); 
			// ... controllo le creature che blocca ...
			for (Permanent attacker : blocker.blockedCreatures.listReference) {
				// ... se almeno 1 attaccante ha Skulk ed il suo attacco è MINORE ...
				if (attacker.checkKeywordAbility("skulk") && 
				    Integer.parseInt(attacker.power[0]) < b_power){
					// ... il blocco non è valido
					System.out.println("Skulk: Blocco non valido!");
					$g.blockValid = false;
				}
			}
		}
		$sce.next();
		update($g)
end




/////////////////////////////////
////////////////////////////////
////////////////////////////////

//martina-damiano cerco keyword ability fortify tra le abilità attivate e setto il booleano 
rule "702.67a"
/*
November 19, 2021
	702.67a	NUOVO NUMERO 
702.67a. Fortify is an activated ability of Fortification cards. "Fortify [cost]" means "[Cost]: 
Attach this Fortification to target land you control. Activate this ability only any time you could cast a sorcery."*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && activated_ability==true && 
			abilityText.startsWith("Fortify ")) from $la
	then	
		$a.setKeyword_ability(true);	
		//$a.setStatic_ability(true);
		$a.setAs_a_sorcery(true);
		$a.setTargetted_ability(true);
		$a.setKeyword_text("Fortify");
		System.out.println("Trovata Fortify: "+$a.getAbilityText());
		update($p)
end

//è as a sorcery e targetted


//martina-damiano cerco keyword ability enchant tra le abilità e setto il booleano 

rule "702.5a"
/*
702.5a 
November 19, 2021
Enchant is a static ability, written "Enchant [object or player]." 
The enchant ability restricts what an Aura spell can target and what an Aura can enchant.
*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(keyword_ability==false && abilityText.startsWith("Enchant ")) from $la
			// ho tolto che deve essere activated abilities
	then	
		$a.setKeyword_ability(true);	
		$a.setStatic_ability(true);
		$a.setKeyword_text("Enchant");
		System.out.println("Trovata Enchant: "+$a.getAbilityText());
		update($p)
end

//martina-damiano cerco costo-effetto-istruzioni nel testo delle abilità attivate 
/*
602.1. 
November 19, 2021
Activated abilities have a cost and an effect. They are written as "[Cost]: [Effect.] 
[Activation instructions (if any).]"
1a. The activation cost is everything before the colon (:). 
An ability's activation cost must be paid by the player who is activating it.
*/
rule "602.1"
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(activated_ability==true && activated_cost==null) from $la
	then
		String[] words 			= $a.getAbilityText().split(":",2);
		String[] costi 			= words[0].split(",");

		int i=0;
		String effect 			="";
		String instruction  	="";
		
		for(i=0;i<costi.length;i++){
			$a.addActivated_cost(costi[i]);
		}
		
		if(words.length>1 && words[1]!=null){
			String[] puntoDivisore 	= words[1].split("\\.",2);
			if(puntoDivisore.length>0 && puntoDivisore[0]!=null){
				effect=puntoDivisore[0];
				if(puntoDivisore.length>1 && puntoDivisore[1]!=null)
				instruction=puntoDivisore[1];
			}
		} 		
		effect=effect.trim();	
		instruction=instruction.trim();	
		$a.setActivated_effect(effect);			
		if(instruction.length()>3){
			$a.setActivated_instruction(instruction);
		}
		System.out.println("Regola 602.1: "+$a.getAbilityText());
		update($p)
end

/*

#########(at non viene riconosciuto
#########(at non viene riconosciuto
#########(at non viene riconosciuto
			
*/

//martina-damiano cerco condizione-effetto-isttuzioni nel testo delle abilità triggered 
rule "603.1"
/*
November 19, 2021
1. Triggered abilities have a trigger condition and an effect. 
They are written as "[When/Whenever/At] [trigger condition or event], [effect]. [Instructions (if any).]"
1.a. A triggered ability may include instructions after its effects that limit what the ability may target or state that it can't be countered.
This text is not part of the ability's effect. It functions while the ability is on the stack.*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(triggered_ability==true && triggered_condition==null) from $la
	then
		String[] words 			= $a.getAbilityText().split(",",2);
		String[] primaVirg 		= words[0].split(" ");

		int i=0;
		int j=0;
		int z=0;
		String condition		="";
		String effect 			="";
		String instruction  	="";
		boolean trovato			=false;
		boolean trovataVirgola	=false;
		boolean trovatoPunto	=false;
		for(i=0;i<primaVirg.length  && !trovato;i++){
			if(primaVirg[i].equals("when") || primaVirg[i].equals("whenever") || primaVirg[i].equals("at")){
				trovato=true;
				for(j=i+1;j<primaVirg.length;j++){
					condition+=" "+primaVirg[j];
				}
			}
		}
		if(words.length>1 && words[1]!=null){
			String[] puntoDivisore 	= words[1].split("\\.",2);
			if(puntoDivisore.length>0 && puntoDivisore[0]!=null){
				effect=puntoDivisore[0];
				if(puntoDivisore.length>1 && puntoDivisore[1]!=null)
				instruction=puntoDivisore[1];
			}
		} 		
		condition=condition.trim();	
		effect=effect.trim();	
		instruction=instruction.trim();	
		$a.setTriggered_effect(effect);
		$a.setTriggered_condition(condition);
		if((condition!="")||(effect!="")||(instruction!=""))
			System.out.println("Regola 603.1: "+$a.getAbilityText());
		if(condition!="")
			System.out.println("Trovata Triggered condition: "+condition);
		if(effect!="")
			System.out.println("Trovata Triggered effect: "+effect);	
		if(instruction.length()>3){
			$a.setTriggered_instruction(instruction);
			System.out.println("Trovata Triggered instruction: "+instruction);
		}
		
		update($p)
end
 
//martina-damiano check delle abilità di loyalty secondo la regola: 
//prima del due punti deve avere un numero preceduto da + o -
//([+-])(([0-9]+))(:)((?:[a-z][a-z]+))
//(.+)([+-])(([0-9]+))(:)((?:[a-z][a-z]+))(.+)
rule "606.1"
/*
	November 19, 2021
Loyalty Abilities
1. Some activated abilities are loyalty abilities, which are subject to special rules.
2. An activated ability with a loyalty symbol in its cost is a loyalty ability. 
    Normally, only planeswalkers have loyalty abilities.*/
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(activated_ability==true && loyalty_ability == false
		&&
		abilityText.matches("([+-−])(([0-9]+))(:)(.+)")
		) from $la
	then	
		$a.setLoyalty_ability(true);
		System.out.println("Trovata LoyaltyAbility : "+$a.getAbilityText());
		update($p)
end


//martina-damiano check di abilità di tipo as_a_sorcery, la stringa si trova sempre a fine testo
rule "606.2"
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(as_a_sorcery == false && abilityText.contains("as a sorcery.")) from $la
	then	
		$a.setAs_a_sorcery(true);
		System.out.println("Trovata as a sorcery "+ $a.getAbilityText());
		update($p)
end



rule "704.5p"
/*
November 19, 2021
	704.5p NUOVO NUMERO
*/
	/* If a creature is attached to an object or player, it becomes unattached and remains on 
		the battlefield. Similarly, if a permanent that's neither an Aura, an Equipment, nor a 
		Fortification is attached to an object or player, it becomes unattached and remains on 
		the battlefield. */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.5q"
/*
November 19, 2021
	704.5q NUOVO NUMERO
*/
	/* If a permanent has both a +1/+1 counter and a -1/-1 counter on it, N +1/+1 and N -1/-1 
		counters are removed from it, where N is the smaller of the number of +1/+1 and -1/-1 
		counters on it. */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end

/*
November 19, 2021
	704.5r NUOVO NUMERO
*/
rule "704.5r"
	/* If a permanent with an ability that says it can't have more than N counters of a certain 
		kind on it has more than N counters of that kind on it, all but N of those counters are 
		removed from it. */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.6a"
/*
	--- November 19, 2021 ---
	704.6a NUOVO NUMERO
	In a Two-Headed Giant game, if a team has 0 or less life, that team loses the game. 
	See rule 810, "Two-Headed Giant Variant." */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.6b"
/*
November 19, 2021
	704.6b NUOVO NUMERO
*/
	/* In a Two-Headed Giant game, if a team has fifteen or more poison counters, 
		that team loses the game. See rule 810, "Two-Headed Giant Variant." */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end



rule "704.6c"
	/* November 19, 2021
	In a Commander game, a player that's been dealt 21 or more combat damage by 
		the same commander over the course of the game loses the game. See rule 903, 
		"Commander." */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.6e"
	/* November 19, 2021
	In an Archenemy game, if a non-ongoing scheme card is face up in the command zone, and no triggered abilities of any scheme are on the stack or waiting to be put on the stack, that 
	 scheme card is turned face down and put on the bottom of its owner's scheme deck. See rule 904, "Archenemy." */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end


rule "704.6f "
	/* November 19, 2021
	 In a Planechase game, if a phenomenon card is face up in the command zone, 
		and it isn't the source of a triggered ability that has triggered but not 
		yet left the stack, the planar controller planeswalks. See rule 901, "Planechase." */
	dialect "mvel"
	agenda-group "general"
	
	when
	
	then
	
end

//QUESTA REGOLA PERMETTE DI AVVISARE I PLAYER QUANDO TENTANO UN ATTEMPT ILLEGALE E DI CANCELLARLO DALLA WM
rule "svalidazione attempt"
dialect "mvel"
salience -1
no-loop true
when
	not $g: Game(stage == Game.GAME_FINISHED)
	$a: Attempt($id:id);
	$p: Player(id==$id);
	$gt: Game($st:stage)
then
	
	System.out.println("Attempt non valido: " +$st);
	GameEngine.sendToNode("Il giocatore " +$p.nickname + " ha tentato un attempt illegale");	
	
	retract($a);
	
end

rule "test get_abilities"
	dialect "mvel"
	agenda-group "general"
	no-loop true
	when
		$g: Game(stage == Game.GAME_STAGE, $b: battleField)
		$p: Permanent(attby_perm != null) from $b
	then
		System.out.println("get abilities " + $p.getAbilities());
		
end

/* //regola di debug tipi
	rule "test get_types"
	dialect "mvel"
	agenda-group "general"
	no-loop true
	when
		$g: Game(stage == Game.GAME_STAGE, $b: battleField)
		$p: Permanent(attby_perm != null) from $b
	then
		System.out.println("name: " + $p.getName());
		System.out.println("supertypes " + $p.getSupertype());
		System.out.println("types " + $p.getCardType());
		System.out.println("subtypes " + $p.getSubtype());
end
*/

/*
// TEST PER NICOLA
rule "114.1b"
no-loop true
agenda-group "general"	
	when
		$g : Game(stage == Game.STARTING_STAGE)
		$p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
		$c : Card() from $lib
		$la: LinkedList() from $c.getAbilities()
		$a : Ability(targetted_ability==false && abilityText.contains("enchant ")) from $la
	then	
		$a.setTargetted_ability(true);
		String[] words = $a.getAbilityText().split(" ");
		int i=0;
		boolean trovato=false;
		if(words.length>2 && words[2]!=null)
			System.out.println(words[2].toString());		
		System.out.println("Trovata Enchant Ability ");// + $a.getAbilityText() + " | Type: " + $a.getTargetType().toString());
		update($p)
end
*/

rule "114.1b"
no-loop true
agenda-group "general"  
  when
    $g : Game(stage == Game.STARTING_STAGE)
    $p : Player($id : id, $nickname: nickname, $deck: deck; $lib: library, library.size() > 0);
    $c : Card() from $lib
    $la: LinkedList() from $c.getAbilities()
    $a : Ability(targetted_ability==false && abilityText.contains("enchant ")) from $la
  then  
    $a.setTargetted_ability(true);
    String[] words = $a.getAbilityText().split(" ");
    int i = 0;
    boolean trovato=false;
    
    if(words[0].equals("enchant") || words[0].equals("enchanted")){
      for(i = 1; i < words.length; i++){	
        if(
	       	words[i].equals("artifact") || 
			words[i].equals("creature") || 
			words[i].equals("player") 	||
			words[i].equals("land") 	|| 
			words[i].equals("spell") 	|| 
			words[i].equals("opponent") || 
			words[i].equals("permanent")|| 
			words[i].equals("Beast")	||
		    words[i].equals("island")	||
		    words[i].equals("swamp")	||
		   	words[i].equals("mountain")	||
		    words[i].equals("forest")	||
		   	words[i].equals("plains")	||
		    words[i].equals("equipment")||
		   	words[i].equals("instant")	||
		    words[i].equals("enchantment")	
     	   ){
          		$a.addTargetType(words[i]);
     			System.out.println("Added: " + words[i]);
         }
     }
    }
    try{
    	System.out.println(
    			  "Trovata Enchant Ability " + $a.getAbilityText() 
    			+ " | Target Type: " + $a.getTargetType().toString()
    			+ " | Nome Carta: "  +$c.getName().get(0)
    			+ " | Tipo carta: "  + $c.getCardType().toString()
    	);
    }catch(Exception e){
    	System.out.println("Error: " + e);
    	System.out.println("TESTO REGOLA >>>>>>>>>>> " + $a.getAbilityText());
    }
    update($p)
end
